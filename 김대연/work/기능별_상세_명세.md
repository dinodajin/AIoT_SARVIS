# SARVIS 기능별 상세 명세

**문서 버전:** 4.0  
**작성일:** 2026-01-29  
**작성자:** AI Assistant  
**기준 문서:** Use_case.md, app_specsheet.md, models.py, order.md, technical_info_collection.md

**변경 이력:**
- v4.1 (2026-01-30): BLE Advertise 방식으로 기기 연결 방식 개선
  - QR코드 스캔 제거 및 BLE Advertise 방식 도입
  - 앱 실행 시 자동 BLE 스캔으로 SARVIS 기기 감지
  - Jetson 전원 ON 시 지속적 BLE Advertise 발산
  - 사용자가 감지된 SARVIS 목록에서 기기 선택 후 연결
- v4.0 (2026-01-29): 벡터 임베딩 로직 Jetson 이동 및 기기 연결 관리 강화
  - 회원가입/로그인/생체정보 재설정 시 벡터 임베딩을 EC2에서 Jetson으로 이동
  - Jetson HTTP 엔드포인트 (http://192.168.x.x:8000/register/upload) 추가
  - 앱 실행 시 기기 연결 상태 감지 로직 ('현재 기기 연결됨'/'기기 연결 시도')
  - 네트워크 미연결 시 BLE 통신으로 네트워크 정보 입력 후 자동 연결
  - 주변 SARVIS 탐색 및 선택 연결 로직 추가
  - 이미 연결된 기기 시 강제 연결 확인 및 세션 탈취 로직 추가
  - 로그아웃 시 기기-휴대폰 연결관계 유지 (공용 휴대폰 대응)
  - 새 휴대폰 연결 시 연결관계 갱신 로직 추가
  - BLE 연결 끊김 시 Heartbeat를 통한 서버 REPORT 및 업데이트 로직 추가
  - **생체 정보 관리 업데이트:** 얼굴/음성 재설정 시 Jetson 로컬 벡터화로 변경
    - Jetson HTTP 엔드포인트: `http://192.168.x.x:8000/biometric/face-update` (얼굴 재설정)
    - Jetson HTTP 엔드포인트: `http://192.168.x.x:8000/biometric/voice-update` (음성 재설정)
    - 앱 → Jetson: 원본 이미지/오디오 전송
    - Jetson: 로컬 임베딩 연산 후 벡터 데이터 EC2 전송
    - S3 사용 제거
- v3.3 (2026-01-28): BLE 통신 및 캡티브 포털 지원 추가
  - 휴대폰-Jetson 간 BLE(GATT) 통신 구조 추가
  - 캡티브 포털 Wi-Fi 연결 및 자동 로그인 지원 추가
  - Jetson-서버 간 WebSocket 통신 (wss://i14a104.p.ssafy.io:8000/ws/) 명확화
  - 연결 복구 및 Heartbeat 시스템 추가
- v3.2 (2026-01-28): 기기 연결 감지 로직 상세화 및 QR코드 스캔 방식 추가
  - 기기와 서버, 서버와 앱 모두 무선연결 구조 반영
  - 기기 연결 감지 로직 명확화 (앱-Jetson WebSocket 연결 확인)
  - QR코드 스캔을 통한 Jetson 서버 URL 획득 로직 추가
  - 자동 로그인 시 저장된 기기 정보로 자동 연결

---

## 목차

1. [네트워크 연결](#1-네트워크-연결)
2. [회원가입](#2-회원가입)
3. [로그인](#3-로그인)
4. [세션 관리](#4-세션-관리)
5. [로봇 제어](#5-로봇-제어)
6. [핸드프리 유튜브 제어](#6-핸드프리-유튜브-제어)
7. [생체 정보 관리](#7-생체-정보-관리)
8. [기기 관리](#8-기기-관리)
9. [프리셋 관리](#9-프리셋-관리)
10. [회원 관리](#10-회원-관리)

---

## 1. 네트워크 연결

### 1.1 기능 개요

**목적:** 사용자가 앱을 통해 SARVIS 기기를 네트워크에 연결하고 WebSocket 통신을 통해 기기 상태를 모니터링

**필수 구성요소:**
- BLE Advertise 스캔 (기기 자동 감지)
- BLE(GATT) 연결 및 통신
- Wi-Fi 스캔 및 연결
- 캡티브 포털 처리 (필요 시)
- EC2 WebSocket 연결 (wss://i14a104.p.ssafy.io:8000/ws/)
- Heartbeat 통신 (30초 간격)
- 연결 복구 시스템

**선행 조건:**
- 사용자가 앱을 설치하고 실행
- Jetson 기기 전원 ON

**후행 조건:**
- 기기가 EC2 서버와 WebSocket 연결 완료
- Heartbeat 통신 시작
- 실시간 기기 상태 모니터링 가능

---

### 1.2 페이지 전환 흐름

```
앱 실행 (최초 연결)
    ↓ (BLE 스캔 시작)
SARVIS 기기 자동 감지 (BLE Advertise)
    ↓ (기기 선택)
BLE 연결 (기기와 앱)
    ↓ (Wi-Fi 스캔)
Wi-Fi 네트워크 선택
    ↓ (캡티브 포털 없음)
Wi-Fi 연결 → EC2 WebSocket 연결
    ↓ (연결 성공)
설정 완료

앱 실행 (최초 연결)
    ↓ (BLE 스캔 시작)
SARVIS 기기 자동 감지 (BLE Advertise)
    ↓ (기기 선택)
BLE 연결
    ↓ (Wi-Fi 네트워크 선택 - 캡티브 포털 있음)
캡티브 포털 로그인 폼 표시
    ↓ (사용자 입력)
자동 로그인 → EC2 WebSocket 연결
    ↓ (연결 성공)
설정 완료

기기 재부팅
    ↓ (저장된 자격증명 로드)
자동 Wi-Fi 연결
    ↓ (캡티브 포털 처리 필요 시)
자동 로그인 → EC2 WebSocket 연결
    ↓ (연결 성공)
Heartbeat 시작
```

---

### 1.3 상세 흐름 및 데이터 흐름

#### 1.3.1 BLE Advertise 스캔 (기기 자동 감지)

**화면:** 기기 연결 화면

**페이지 전환:**
- BLE 스캔 → SARVIS 목록 표시 → 기기 선택 → BLE 연결 시도

**동작 흐름:**
1. 앱 실행 시 자동으로 BLE 스캔 시작
2. Jetson의 BLE Advertise 신호 감지 (전원 ON 시 지속적 발산)
3. 감지된 SARVIS 기기 목록 표시
4. 사용자가 기기 선택 (여러 기기가 있을 경우)
5. 기기 ID 로컬 저장
6. BLE 연결 시도

**BLE Advertise 포맷:**
- Device ID: Jetson 기기 식별자 (예: `JETSON-001`)
- Device Name: 블루투스 이름 (예: `SARVIS-Device`)
- WebSocket URL: Jetson WebSocket 주소 (예: `ws://192.168.x.x:8000/ws`)

**데이터 흐름:**
```
[앱] BLE 스캔 시작
  ↓ BLE Advertise 신호 감지 (JETSON-001)
  ↓ SARVIS 목록 표시
[사용자] 기기 선택
  ↓ 기기 ID 및 WebSocket URL 저장
[앱] BLE 연결 시도
```

---

#### 1.3.2 BLE(GATT) 연결 (기기와 앱 간 통신)

**화면:** 연결 진행 중 화면

**페이지 전환:**
- BLE 연결 → Wi-Fi 네트워크 스캔

**동작 흐름:**
1. 앱이 기기 ID로 BLE(GATT) 스캔
2. 기기 발견 후 연결 (페어링 없는 통신)
3. 핸드셰이크 메시지 교환
4. 연결 성공 시 "기기 연결 완료" 메시지

**BLE 통신 규격:**
- **프로토콜:** GATT (Generic Attribute Profile)
- **보안:** BLE 보안 레벨 4 (암호화)
- **연결 방식:** 페어링 없는 통신으로 OS 제약 최소화

**데이터 흐름:**
```
[앱] BLE(GATT)로 기기 스캔
  ↓ 기기 발견 (기기 ID: JETSON-001)
  ↓ BLE 연결 요청
[Jetson] BLE 연결 수신
  ↓ 핸드셰이크 메시지 전송
[앱] 핸드셰이크 확인
  ↓ "기기 연결 완료" 메시지
```

**Timeout 설정:** 30초
- BLE 연결 Timeout

---

#### 1.3.3 Wi-Fi 스캔 및 네트워크 선택

**화면:** Wi-Fi 네트워크 목록 화면

**페이지 전환:**
- BLE 연결 → Wi-Fi 네트워크 스캔

**동작 흐름:**
1. 앱에서 Wi-Fi 스캔 요청 (BLE로 Jetson에 전송)
2. Jetson이 Wi-Fi 스캔 수행 (5-10초)
3. 감지된 네트워크 목록 BLE로 앱에 전송
4. 앱에서 네트워크 목록 표시
5. 사용자가 타겟 네트워크 선택

**Wi-Fi 스캔 데이터:**
- SSID (네트워크 이름)
- 신호 강도 (0-100)
- 보안 유형 (WPA2, WEP, Open)
- 캡티브 포털 여부 (예측)

**데이터 흐름:**
```
[앱] Wi-Fi 스캔 요청 (BLE)
[Jetson] BLE 메시지 수신
  ↓ Wi-Fi 스캔 수행 (5-10초)
  ↓ 감지된 네트워크 목록 생성
  ↓ BLE로 앱에 전송
[앱] 네트워크 목록 표시
  ↓ 사용자 네트워크 선택
```

**Timeout 설정:** 15초
- Wi-Fi 스캔 Timeout

---

#### 1.3.4 Wi-Fi 연결 (일반 Wi-Fi)

**화면:** 비밀번호 입력 화면 (필요 시)

**페이지 전환:**
- 비밀번호 입력 → Wi-Fi 연결 → EC2 WebSocket 연결

**동작 흐름:**
1. 사용자가 비밀번호 입력 (필요 시)
2. Wi-Fi 정보 BLE로 Jetson에 전송 (SSID, 비밀번호)
3. Jetson이 Wi-Fi 연결
4. 연결 성공 시 EC2 WebSocket 연결 시도

**데이터 흐름:**
```
[앱] 비밀번호 입력 (필요 시)
  ↓ Wi-Fi 정보 전송 (BLE): { "ssid": "...", "password": "..." }
[Jetson] BLE 메시지 수신
  ↓ Wi-Fi 연결 시도
  ↓ 연결 성공 확인
  ↓ EC2 WebSocket 연결 시도 (wss://i14a104.p.ssafy.io:8000/ws/)
[Jetson] WebSocket 연결 수신
  ↓ Heartbeat 시작 (30초 간격)
[앱] "설정 완료" 메시지
```

---

#### 1.3.5 캡티브 포털 처리

**화면:** 캡티브 포털 로그인 폼

**페이지 전환:**
- 캡티브 포털 감지 → 로그인 폼 표시 → 자동 로그인 → EC2 WebSocket 연결

**동작 흐름:**
1. Jetson이 캡티브 포털 감지 (HTTP 리디렉션)
2. 캡티브 포털 URL BLE로 앱에 전송
3. 앱에서 캡티브 포털 로그인 폼 표시
4. 사용자가 아이디/비밀번호 입력
5. 입력 정보 BLE로 Jetson에 전송
6. Jetson이 자동 로그인 실행
7. 로그인 성공 시 EC2 WebSocket 연결 시도

**캡티브 포털 감지 방법:**
- HTTP 리디렉션 확인
- DNS 쿼리 확인
- 특정 포트 접근 시도

**데이터 흐름:**
```
[Jetson] Wi-Fi 연결 후 캡티브 포털 감지
  ↓ HTTP 리디렉션 확인
  ↓ 캡티브 포털 URL 획득
  ↓ BLE로 앱에 전송: { "type": "captive_portal", "url": "..." }
[앱] 캡티브 포털 로그인 폼 표시
  ↓ 사용자 아이디/비밀번호 입력
  ↓ BLE로 Jetson에 전송: { "type": "login", "username": "...", "password": "..." }
[Jetson] BLE 메시지 수신
  ↓ 자동 로그인 실행
  ↓ 로그인 성공 확인
  ↓ EC2 WebSocket 연결 시도 (wss://i14a104.p.ssafy.io:8000/ws/)
[Jetson] WebSocket 연결 수신
  ↓ Heartbeat 시작 (30초 간격)
[앱] "설정 완료" 메시지
```

**Timeout 설정:** 30초
- 캡티브 포털 로그인 Timeout

---

#### 1.3.6 EC2 WebSocket 연결

**화면:** 연결 진행 중 화면

**페이지 전환:**
- 연결 진행 → Heartbeat 시작

**동작 흐름:**
1. Jetson이 EC2 WebSocket 연결 시도 (wss://i14a104.p.ssafy.io:8000/ws/)
2. 연결 성공 시 첫 번째 Heartbeat 전송
3. 서버에서 연결 확인
4. Heartbeat 주기적 전송 (30초 간격)

**WebSocket 엔드포인트:**
- 기기 WebSocket 연결: `wss://i14a104.p.ssafy.io:8000/ws/device/{device_id}/`
- Heartbeat 엔드포인트: `wss://i14a104.p.ssafy.io:8000/ws/heartbeat/`

**Heartbeat 메시지 형식:**
```json
{
  "type": "heartbeat",
  "device_id": "JETSON-001",
  "timestamp": 1640739900,
  "wifi_signal": 85,
  "captive_portal_session": "active"
}
```

**데이터 흐름:**
```
[Jetson] EC2 WebSocket 연결 시도
  ↓ wss://i14a104.p.ssafy.io:8000/ws/
[서버] WebSocket 연결 수신
  ↓ 기기 등록
[Jetson] 첫 번째 Heartbeat 전송
[서버] Heartbeat 수신 및 처리
  ↓ 기기 상태 저장
  ↓ 응답: { "type": "heartbeat_ack", "device_id": "JETSON-001", "timestamp": 1640739900 }
[Jetson] 30초 간격으로 Heartbeat 전송
```

**Timeout 설정:** 10초
- WebSocket 연결 Timeout

---

#### 1.3.7 자동연결 (재부팅 후)

**화면:** 자동 연결 중 화면 (백그라운드)

**페이지 전환:**
페이지 전환 없음, 백그라운드에서 자동 실행

**동작 흐름:**
1. Jetson 재부팅
2. 저장된 자격증명 로드
   - Wi-Fi SSID (암호화 불필요)
   - Wi-Fi 비밀번호 (AES-256 암호화)
   - 캡티브 포털 URL (암호화 불필요)
   - 캡티브 포털 아이디/비밀번호 (AES-256 암호화)
   - EC2 WebSocket 서버 주소 (암호화 불필요)
3. Wi-Fi 자동 연결
4. 캡티브 포털 처리 (필요 시)
5. EC2 WebSocket 연결 (wss://i14a104.p.ssafy.io:8000/ws/)
6. Heartbeat 시작 (30초 간격)

**저장 정보 구조:**
```json
{
  "wifi_ssid": "MyWiFi",
  "wifi_password": "encrypted_password",
  "captive_portal_url": "http://portal.example.com",
  "captive_portal_username": "encrypted_username",
  "captive_portal_password": "encrypted_password",
  "websocket_url": "wss://i14a104.p.ssafy.io:8000/ws/"
}
```

**데이터 흐름:**
```
[Jetson] 재부팅
  ↓ 저장된 자격증명 로드
  ↓ Wi-Fi 자동 연결 시도
  ↓ (캡티브 포털 필요 시) 자동 로그인
  ↓ EC2 WebSocket 연결 시도 (wss://i14a104.p.ssafy.io:8000/ws/)
[서버] WebSocket 연결 수신
  ↓ 기기 인식
[Jetson] 첫 번째 Heartbeat 전송
[서버] Heartbeat 수신 및 처리
  ↓ 기기 상태 저장
[Jetson] 30초 간격으로 Heartbeat 전송
```

---

#### 1.3.8 연결 상태 모니터링 (Heartbeat)

**Heartbeat 간격:** 30초

**실행 흐름:**
1. Jetson이 주기적으로(30초 간격) WebSocket으로 Heartbeat 메시지 전송
2. 서버에서 Heartbeat 수신 및 처리
3. Wi-Fi 신호 강도, 캡티브 포털 세션 상태 저장
4. 앱에 실시간 기기 상태 전송 (WebSocket)

**서버 → 앱 WebSocket 메시지:**
```json
{
  "type": "heartbeat_update",
  "device_id": "JETSON-001",
  "wifi_signal": 85,
  "connection_status": "connected",
  "captive_portal_session": "active"
}
```

**연결 끊김 감지:**
```json
{
  "type": "device_offline",
  "device_id": "JETSON-001",
  "last_seen": 1640739900,
  "reason": "connection_timeout"
}
```

**연결 복구 감지:**
```json
{
  "type": "device_online",
  "device_id": "JETSON-001",
  "reconnect_time": 1640739950
}
```

**데이터 흐름:**
```
[Jetson] 30초 간격으로 Heartbeat (WebSocket)
  ↓ WebSocket 메시지: { "type": "heartbeat", "device_id": "JETSON-001", "timestamp": 1640739900, "wifi_signal": 85 }
[서버] 
  ↓ Heartbeat 수신 및 처리
  ↓ 기기 상태 저장
  ↓ 앱에 상태 전송 (WebSocket): { "type": "heartbeat_update", "device_id": "JETSON-001", "wifi_signal": 85, "connection_status": "connected" }
[앱] UI 업데이트 (기기 상태 표시)
```

---

#### 1.3.9 앱 실행 시 기기 연결 상태 감지

**화면:** 로그인 초기 화면

**페이지 전환:**
없음, 백그라운드에서 자동 실행

**실행 흐름:**
1. 앱 실행 시 저장된 Jetson IP 확인 (192.168.x.x)
2. HTTP 연결 시도로 연결 상태 확인
3. **상태 분기:**
   - **"현재 기기 연결됨"**: 기존 연결 유지, 로그인 성공 시 그대로 사용 가능
   - **"기기 연결 시도"**: 신규 연결 프로세스 시작

**상태 표시:**
- **"현재 기기 연결됨" (녹색 점):** WebSocket 연결 완료 상태
- **"기기 연결 시도" (회색 점):** 연결 대기 상태

**데이터 흐름:**
```
[앱] 앱 실행
  ↓ 저장된 Jetson IP 확인 (192.168.x.x)
  ↓ HTTP 연결 시도
[Jetson] 연결 확인
  ↓ 응답: { "status": "connected" }
[앱] "현재 기기 연결됨" 상태 표시 (녹색 점)

[앱] 앱 실행
  ↓ 저장된 Jetson IP 확인 (192.168.x.x)
  ↓ HTTP 연결 시도
[Jetson] 연결 실패
  ↓ 응답: { "status": "disconnected" }
[앱] "기기 연결 시도" 상태 표시 (회색 점)
  ↓ 주변 기기 탐색 시작
```

---

#### 1.3.10 네트워크 미연결 시 BLE 통신 (기기가 네트워크에 연결되어 있지 않을 경우)

**화면:** 기기 연결 화면

**페이지 전환:**
"기기 연결 시도" → BLE 기기 탐색 → 네트워크 정보 입력 → 자동 연결

**실행 흐름:**
1. 앱이 "기기 연결 시도" 상태 확인
2. 주변 기기 탐색 (BLE 스캔)
3. SARVIS가 열어놓은 BLE 통신 감지
4. BLE로 네트워크 정보 전송 (SSID, 비밀번호)
5. Jetson이 네트워크 정보 수신
6. Jetson이 자동으로 해당 네트워크 연결
7. 연결 성공 시 "현재 기기 연결됨" 상태로 전환

**BLE 통신 포맷:**
```json
{
  "type": "wifi_credentials",
  "ssid": "MyWiFi",
  "password": "encrypted_password"
}
```

**데이터 흐름:**
```
[앱] "기기 연결 시도" 상태
  ↓ 주변 기기 탐색 (BLE 스캔)
  ↓ SARVIS BLE 감지
[Jetson] BLE 통신 대기 중
[앱] BLE로 네트워크 정보 전송: { "type": "wifi_credentials", "ssid": "MyWiFi", "password": "encrypted_password" }
[Jetson] BLE 메시지 수신
  ↓ 네트워크 연결 시도
  ↓ 연결 성공
  ↓ HTTP 응답: { "status": "connected" }
[앱] "현재 기기 연결됨" 상태 표시 (녹색 점)
```

**Timeout 설정:** 30초
- BLE 연결 및 네트워크 연결 Timeout

---

#### 1.3.11 주변 SARVIS 탐색 (기기가 네트워크에 연결되어 있을 경우)

**화면:** 기기 연결 화면

**페이지 전환:**
"기기 연결 시도" → BLE 기기 탐색 → SARVIS 목록 → 기기 연결

**실행 흐름:**
1. 앱이 "기기 연결 시도" 상태 확인
2. 주변 기기 탐색 (BLE 스캔)
3. 가까운 SARVIS 목록 표시
4. 사용자가 SARVIS 선택
5. 선택된 SARVIS와 기기 연결
6. 연결 성공 시 "현재 기기 연결됨" 상태로 전환

**SARVIS 목록 표시:**
- 기기 이름 (예: SARVIS-001)
- 신호 강도 (0-100)
- 거리 (예: 2m)

**데이터 흐름:**
```
[앱] "기기 연결 시도" 상태
  ↓ 주변 기기 탐색 (BLE 스캔)
  ↓ SARVIS 목록 표시
[앱] 사용자 SARVIS 선택
  ↓ BLE 연결 시도
[Jetson] BLE 연결 수신
  ↓ 연결 성공
  ↓ HTTP 응답: { "status": "connected", "device_id": "JETSON-001" }
[앱] "현재 기기 연결됨" 상태 표시 (녹색 점)
```

**Timeout 설정:** 30초
- BLE 연결 Timeout

---

#### 1.3.12 이미 연결된 기기 확인 및 강제 연결

**화면:** 기기 연결 화면

**페이지 전환:**
SARVIS 선택 → 기기 연결 확인 → 강제 연결 확인 → 연결 완료

**실행 흐름:**
1. 사용자가 SARVIS 선택
2. 서버에서 UserDeviceConnection 조회
3. 이미 연결된 기기 확인
4. **이미 연결된 기기 있을 경우:**
   - "이미 연결된 기기가 있습니다. 강제 연결하시겠습니까?" 확인 팝업
   - 확인 시 세션 탈취 및 연결관계 갱신
   - 취소 시 기기 선택 화면으로 복귀
5. 연결 성공 시 "현재 기기 연결됨" 상태로 전환

**데이터 흐름:**
```
[앱] 사용자 SARVIS 선택
  ↓ GET /api/devices/{device_id}/current-user
[서버] 
  ↓ UserDeviceConnection 조회
  ↓ 연결된 사용자 확인
  ↓ 응답: { "has_connected_user": true, "nickname": "아빠" }
[앱] "이미 연결된 기기가 있습니다. 강제 연결하시겠습니까?" 확인 팝업
[사용자] 확인 선택
  ↓ POST /api/devices/{device_id}/force-connect
[서버] 
  ↓ 기존 UserDeviceConnection 업데이트 (세션 탈취)
  ↓ 새 UserDeviceConnection 생성
  ↓ 응답: { "success": true, "message": "연관계 갱신 완료" }
[앱] "현재 기기 연결됨" 상태 표시 (녹색 점)
```

**API 요약:**
1. `GET /api/devices/{device_id}/current-user` - 기기에 연결된 사용자 확인
   - Response (성공): `{ "has_connected_user": true, "nickname": "아빠" }`
   - Response (실패): `{ "has_connected_user": false }`
   - **Timeout:** 2초

2. `POST /api/devices/{device_id}/force-connect` - 강제 연결 (세션 탈취)
   - Request: `{ "user_id": 1 }`
   - Response (성공): `{ "success": true, "message": "연관계 갱신 완료" }`
   - **Timeout:** 3초

---

#### 1.3.13 BLE 연결 끊김 감지 및 Heartbeat REPORT

**화면:** 모든 화면 공통

**페이지 전환:**
없음, 백그라운드에서 자동 감지

**실행 흐름:**
1. 휴대폰과 SARVIS의 BLE 연결 끊김 감지
2. Jetson이 Heartbeat를 통해 서버에 REPORT 전송
3. 서버가 UserDeviceConnection 업데이트 (연결된 기기: Null)
4. 앱에 연결 해제 알림 전송 (WebSocket)

**Heartbeat REPORT 메시지 형식:**
```json
{
  "type": "connection_report",
  "device_id": "JETSON-001",
  "status": "disconnected",
  "timestamp": 1640739900
}
```

**데이터 흐름:**
```
[Jetson] BLE 연결 끊김 감지
  ↓ Heartbeat REPORT 전송 (WebSocket): { "type": "connection_report", "device_id": "JETSON-001", "status": "disconnected", "timestamp": 1640739900 }
[서버] 
  ↓ UserDeviceConnection 업데이트 (connected_device: Null)
  ↓ 연결 상태 저장
  ↓ 앱에 알림 전송 (WebSocket): { "type": "connection_status", "status": "disconnected" }
[앱] 연결 해제 알림 수신
  ↓ "기기와 연결이 끊어졌습니다." 메시지 표시
  ↓ 상단 인디케이터 "기기 연결 대기중..." (회색 점)으로 변경
```

**Timeout 설정:** 10초
- Heartbeat REPORT 전송 Timeout

---

#### 1.3.14 로그아웃 시 연결관계 유지

**화면:** 메뉴 → 로그아웃

**페이지 전환:**
메뉴 → 로그아웃 확인 → 로그아웃 완료

**실행 흐름:**
1. 사용자가 메뉴에서 "로그아웃" 선택
2. "로그아웃하시겠습니까?" 확인 팝업
3. 확인 시 로그아웃 진행
4. 세션 종료, JWT 토큰 삭제
5. **기기와 휴대폰의 연결관계 유지** (공용 휴대폰 상황 대응)
6. 로그인 초기 화면으로 이동

**데이터 흐름:**
```
[앱] 메뉴에서 로그아웃 선택
  ↓ 확인 팝업
  ↓ POST /api/auth/logout
[서버] 
  ↓ 세션 종료
  ↓ JWT 토큰 무효화
  ↓ UserDeviceConnection 유지 (기기-휴대폰 연결관계 유지)
[앱] 로그인 초기 화면으로 이동
  ↓ 로컬 토큰 삭제
  ↓ 기기 연결 상태 유지
```

**중요:** 로그아웃 시에도 기기와 휴대폰의 연결관계는 유지됩니다. 이는 공용 휴대폰 상황에서 다른 사용자가 기기를 사용할 수 있도록 하기 위함입니다.

---

#### 1.3.15 새 휴대폰 연결 시 연결관계 갱신

**화면:** 로그인 초기 화면

**페이지 전환:**
"새로운 휴대폰"으로 SARVIS에 연결 → 연결관계 갱신 → 로그인 완료

**실행 흐름:**
1. 사용자가 "새로운 휴대폰"으로 SARVIS에 연결 시도
2. 서버에서 기존 UserDeviceConnection 조회
3. 기존 연결관계 확인
4. "이미 연결된 기기가 있습니다. 연결관계를 갱신하시겠습니까?" 확인 팝업
5. 확인 시 연결관계 갱신 (세션 탈취)
6. 연관계 갱신 완료
7. 로그인 완료

**데이터 흐름:**
```
[앱] "새로운 휴대폰"으로 SARVIS에 연결 시도
  ↓ POST /api/devices/{device_id}/connect
[서버] 
  ↓ 기존 UserDeviceConnection 조회
  ↓ 연결된 사용자 확인
  ↓ 응답: { "has_connected_user": true, "nickname": "아빠" }
[앱] "이미 연결된 기기가 있습니다. 연결관계를 갱신하시겠습니까?" 확인 팝업
[사용자] 확인 선택
  ↓ POST /api/devices/{device_id}/force-connect
[서버] 
  ↓ 기존 UserDeviceConnection 업데이트 (connected_device: Null)
  ↓ 새 UserDeviceConnection 생성
  ↓ 응답: { "success": true, "message": "연관계 갱신 완료" }
[앱] 연관계 갱신 완료
  ↓ 로그인 완료
```

**API 요약:**
1. `POST /api/devices/{device_id}/connect` - 기기 연결 시도
   - Request: `{ "user_id": 1 }`
   - Response (성공): `{ "success": true, "message": "연결 완료" }`
   - Response (이미 연결됨): `{ "has_connected_user": true, "nickname": "아빠" }`
   - **Timeout:** 3초

2. `POST /api/devices/{device_id}/force-connect` - 강제 연결 (연관계 갱신)
   - Request: `{ "user_id": 1 }`
   - Response (성공): `{ "success": true, "message": "연관계 갱신 완료" }`
   - **Timeout:** 3초

---

#### 1.3.16 연결 복구 시스템

**복구 시나리오:**

| 시나리오 | 복구 방식 | 사용자 개입 |
|---------|----------|-----------|
| Wi-Fi 신호 끊김 | 자동 재연결 (최대 5회) | ❌ |
| 캡티브 포털 세션 만료 | 자동 로그인 (최대 3회) | ⚠️ (실패 시 재인증) |
| EC2 WebSocket 서버 중단 | 자동 재연결 (Exponential Backoff) | ❌ |
| Wi-Fi 비밀번호 변경 | 앱에서 재설정 | ✅ |
| 캡티브 포털 자격증명 만료 | 앱에서 재인증 | ✅ |
| BLE 연결 끊김 | 자동 재연결 (최대 3회) | ⚠️ (실패 시 사용자 알림) |
| 네트워크 완전 장애 | 대기 후 재시도 | ⚠️ (장기 시 앱 알림) |

**Exponential Backoff 재시도 전략:**
```python
재시도 시간: [1초, 2초, 4초, 8초, 16초, 32초, 64초, 128초, 300초, 600초]
최대 재시도: 10회
```

**데이터 흐름:**
```
[Jetson] Wi-Fi 신호 끊김 감지
  ↓ 자동 재연결 시도 (최대 5회)
  ↓ 연결 성공 → EC2 WebSocket 재연결
  ↓ 연결 실패 → Exponential Backoff 재시도
[서버] 복구 상태 모니터링
  ↓ 앱에 상태 전송 (WebSocket)
[앱] 연결 상태 표시
  ↓ (사용자 개입 필요 시) 알림 표시
```

---

### 1.4 데이터 모델

**관련 모델:**
- Device
- Session
- UserDeviceConnection

**필드 관계:**
```
Device (1) → UserDeviceConnection (N)
Device (1) → Session (N)
User (1) → UserDeviceConnection (N)
```

---

### 1.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| 기기 상태 조회 | GET | `/api/devices/{device_id}/status` | 기기 연결 상태 조회 | 2초 |
| 기기 연결 요청 | POST | `/api/devices/{device_id}/connect` | 기기 연결 요청 | 3초 |
| 강제 기기 연결 | POST | `/api/devices/{device_id}/force-connect` | 강제 기기 연결 (세션 탈취) | 3초 |
| WebSocket 기기 연결 | WebSocket | `/ws/device/{device_id}/` | Jetson WebSocket 연결 | 10초 |
| WebSocket Heartbeat | WebSocket | `/ws/heartbeat/` | Heartbeat 통신 | 30초 간격 |

---

### 1.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| BLE 연결 실패 | 400 | BLE_CONNECTION_FAILED | "기기를 찾을 수 없습니다." | 재연결 요청 |
| Wi-Fi 연결 실패 | 400 | WIFI_CONNECTION_FAILED | "Wi-Fi 연결에 실패했습니다." | 재시도 요청 |
| 캡티브 포털 로그인 실패 | 400 | CAPTIVE_PORTAL_LOGIN_FAILED | "로그인에 실패했습니다. 자격증명을 확인해주세요." | 재인증 요청 |
| WebSocket 연결 실패 | 500 | WEBSOCKET_CONNECTION_FAILED | "서버 연결에 실패했습니다." | Exponential Backoff 재시도 |

---

### 1.7 UX 요구사항

| 항목 | 요구사항 |
|------|----------|
| QR 코드 스캔 | 자동 QR 코드 인식 및 파싱 |
| BLE 연결 | 연결 진행률 표시 |
| Wi-Fi 스캔 | 네트워크 목록 실시간 표시 (신호 강도 포함) |
| 캡티브 포털 로그인 | 간단한 로그인 폼 UI |
| 연결 상태 | 실시간 연결 상태 인디케이터 (녹색/빨간색) |
| 에러 메시지 | 명확한 에러 원인 및 해결 방법 제시 |
| 자동 연결 | 백그라운드에서 자동 실행, 사용자에게 알림 |

---

### 1.8 Timeout 설정 요약

| 항목 | Timeout | 설명 |
|------|---------|------|
| QR 코드 스캔 | 30초 | QR 코드 인식 시간 |
| BLE 연결 | 30초 | BLE(GATT) 연결 시간 |
| Wi-Fi 스캔 | 15초 | Wi-Fi 네트워크 스캔 시간 |
| Wi-Fi 연결 | 30초 | Wi-Fi 연결 시간 |
| 캡티브 포털 로그인 | 30초 | 캡티브 포털 로그인 시간 |
| WebSocket 연결 | 10초 | EC2 WebSocket 연결 시간 |
| Heartbeat 주기 | 30초 | Heartbeat 전송 간격 |

---

### 1.9 보안 요구사항

| 항목 | 요구사항 |
|------|----------|
| 자격증명 저장 | 모든 자격증명 AES-256 암호화 후 저장 |
| BLE 통신 | BLE 보안 레벨 4 (암호화) |
| WebSocket 연결 | WSS (TLS 1.3) 사용 |
| 캡티브 포털 세션 | 주기적 갱신 권장 |
| 기기 식별 | 기기 ID로 고유 식별 |

---

## 2. 회원가입

### 2.1 기능 개요

**목적:** 신규 사용자가 SARVIS 서비스에 가입하여 모든 기능을 사용할 수 있도록 사용자 계정 생성

**필수 구성요소:**
- 회원가입 초기 화면
- 정보 입력 화면 (닉네임, 아이디, 비밀번호, 이메일, 약관 동의)
- 사용자 등록 화면 (얼굴 원본 이미지 수집)
- 음성 등록 화면 (음성 원본 오디오 수집, 선택사항)

**선행 조건:**
- 사용자가 앱을 최초 실행하여 로그인 초기 화면에 접속
- 앱 최초 실행 시 접근성 서비스 권한 요청 완료

**후행 조건:**
- 회원가입 완료 후 자동 로그인
- 기기 연결(WebSocket) 후 바로 메인 화면(홈 탭)으로 이동

---

### 2.2 페이지 전환 흐름

```
로그인 초기 화면
    ↓ (회원가입 버튼 클릭)
회원가입 초기 화면
    ↓ (정보 입력 완료 버튼 클릭)
사용자 등록 화면 (Step 2)
    ↓ (얼굴 원본 이미지 Jetson 전송 및 벡터화 완료)
음성 등록 화면 (Step 3)
    ↓ (음성 등록 완료 또는 건너뛰기)
제어 메인 - 홈 탭
```

---

### 2.3 상세 흐름 및 데이터 흐름

#### 2.3.1 회원가입 시작

**화면:** 로그인 초기 화면 → 회원가입 초기 화면

**동작:**
1. 사용자가 로그인 초기 화면에서 "회원가입" 버튼 클릭
2. 회원가입 초기 화면으로 이동

**취소:**
- 어느 단계에서든 "가입 취소" 또는 "뒤로" 버튼 클릭
- **UX 요구사항:** "회원가입을 취소하면 모든 정보가 초기화됩니다. 정말 취소하시겠습니까?" 확인 팝업 표시
- 확인 시 모든 절차 초기화 후 로그인 초기 화면으로 복귀
- 취소 시 현재 화면 유지

---

#### 2.3.2 Step 1: 정보 입력

**화면:** 정보 입력 화면

**페이지 전환 조건:**
- 모든 필수 입력 항목이 올바르게 입력되었을 때 "정보 입력 완료" 버튼 활성화
- 버튼 클릭 시 사용자 등록 화면으로 이동

**필수 입력 항목:**

##### 2.3.2.1 닉네임 입력

- **입력 필드:** 닉네임 입력 필드
- **형식 검증:** 한글, 영문, 숫자 2-20자
- **실시간 검증:** 불가능한 문자 입력 시 경고
- **UX 요구사항:** 입력 중 실시간으로 유효성 표시 (녹색 체크 또는 빨간색 X)
- **DB 저장:** User 모델의 nickname 필드

##### 2.3.2.2 아이디 입력

- **입력 필드:** 아이디 입력 필드
- **형식 검증:** 영문/숫자 5-20자
- **실시간 검증:** 형식 오류 시 "아이디 형식이 올바르지 않습니다." (빨간색)
- **중복확인:**
  - "중복확인" 버튼 클릭 시 `POST /api/auth/check-id` API 호출
  - 사용 가능: "사용 가능한 아이디입니다." (초록색) + 필드 비활성화 + "아이디 변경" 버튼 표시
  - 중복: "이미 사용 중인 아이디입니다." (빨간색)
  - 형식 오류: "아이디 형식이 올바르지 않습니다." (빨간색)
- **아이디 변경:** 중복 확인 후 표시, 클릭 시 아이디 수정 가능
- **UX 요구사항:** 중복확인 버튼 클릭 시 로딩 스피너 표시 (최대 2초)
- **DB 저장:** User 모델의 login_id 필드 (Unique Key)

##### 2.3.2.3 이메일 입력

- **입력 필드:** 이메일 아이디 입력 필드
- **도메인 선택:** 드롭다운 (naver.com, gmail.com, daum.net, hanmail.net, 직접 입력)
- **직접 입력 선택 시:** 도메인 입력 필드 표시
- **실시간 검증:** 이메일 형식 피드백
- **중복확인 및 인증번호 발송:** 
  - "중복확인 및 인증번호 발송" 버튼 클릭 시 `POST /api/email/send-code` API 호출
  - 사용 가능: "사용 가능한 이메일입니다." (초록색) + 인증번호 입력 필드 표시
  - 중복: "이미 사용 중인 이메일입니다." (빨간색)
  - **UX 요구사항:** 버튼 클릭 시 로딩 스피너 표시 (최대 3초)
- **DB 저장:** User 모델의 email 필드 (Unique Key)

##### 2.3.2.4 이메일 인증

- **입력 필드:** 인증번호 입력 필드 (6자리)
- **유효기간 타이머:** 05:00 (5분)
  - **Timeout 설정:** 5분 (300초) 후 인증번호 만료
  - 타이머 00:00 도달 시 "인증번호가 만료되었습니다. 재발송 버튼을 클릭해주세요." 메시지
- **"인증하기" 버튼:** 6자리 입력 시 활성화
- **인증 성공:** 
  - `POST /api/email/verify` API 호출
  - "인증 완료!" 메시지 (초록색) + 필드 비활성화
- **인증 실패:** 
  - "인증 코드가 올바르지 않습니다." 메시지 (빨간색)
  - 입력 필드 초기화 및 포커스 이동
- **"인증번호 재발송" 버튼:** 
  - 60초 후 활성화
  - 클릭 시 새로운 인증번호 발송 및 타이머 재시작
- **TTL:** 5분 (300초)
- **UX 요구사항:** 인증번호 입력 시 실시간으로 6자리인지 확인 및 인증하기 버튼 활성화

##### 2.3.2.5 비밀번호 입력

- **입력 필드:** 비밀번호 입력 필드
- **형식 검증:** 영문, 숫자, 특수문자 8-20자
- **실시간 검증 및 피드백:**
  - 조건 미충족: "비밀번호에 영문, 숫자, 특수문자가 필요합니다." (빨간색)
  - 사용 가능: "사용 가능한 비밀번호입니다." (초록색)
- **UX 요구사항:** 입력 중 실시간으로 조건별 체크리스트 표시
- **DB 저장:** User 모델의 password 필드 (bcrypt hash)

##### 2.3.2.6 비밀번호 확인

- **입력 필드:** 비밀번호 확인 필드
- **실시간 일치 여부 검증:**
  - 불일치: "비밀번호가 일치하지 않습니다." (빨간색)
  - 일치: "비밀번호가 일치합니다." (초록색)
- **UX 요구사항:** 비밀번호와 비밀번호 확인이 일치할 때만 녹색 체크 표시

##### 2.3.2.7 약관 동의

- **"전체 동의" 체크박스:** 모든 필수 약관 선택/해제
- **필수 약관:**
  - [필수] 서비스 이용약관 동의 + "약관 보기" (모달)
  - [필수] 개인정보 수집 및 이용 동의 + "약관 보기" (모달)
  - [필수] 민감정보 수집 및 이용 동의 + "약관 보기" (모달)
- **"정보 입력 완료" 버튼:** 모든 필수 약관 동의 시 활성화
- **UX 요구사항:** "약관 보기" 클릭 시 모달로 전체 약관 텍스트 표시

##### 2.3.2.8 캐싱 로직 및 데이터 흐름

**Redis 캐시 구조:**
- **Key:** `signup:temp:{uuid}`
- **TTL:** 1800초 (30분)

**캐시 데이터:**
```json
{
  "login_id": "hong123",
  "uuid": "550e8400-e29b-41d4-a716-446655440000000",
  "password": "hashed_password",
  "email": "hong@example.com",
  "nickname": "대연",
  "created_at": "2026-01-28T12:00:00Z"
}
```

**데이터 흐름:**
```
[앱] 
  ↓ POST /api/register/step1/ (닉네임, 아이디, 비밀번호, 이메일)
[서버] 
  ↓ 유효성 검증
  ↓ 임시 UUID 생성
  ↓ Redis 캐시에 임시 저장 (Key: signup:temp:{uuid}, TTL: 30분)
  ↓ 저장 데이터: {login_id, uuid, password, email, nickname, created_at}
  * (참고: 기기 연결은 앱 실행 시부터 세션 만료까지 지속적으로 감지하며, WebSocket을 통해 Jetson과의 연결 상태를 모니터링합니다.)
[앱] 사용자 등록 화면으로 이동

[앱]
  ↓ POST /api/email/send-code (이메일)
[서버] 
  ↓ 인증번호 생성
  ↓ 이메일 전송
[앱] 인증번호 입력 필드 표시

[앱]
  ↓ POST /api/email/verify (이메일, 인증코드)
[서버] 
  ↓ Redis 캐시에서 uuid로 임시 회원가입 데이터 조회
  ↓ 인증 성공 (코드 일치 시)
  ↓ 인증 실패 (코드 불일치 시)
[앱] 인증 완료 메시지 표시 (성공 시) / 인증 실패 메시지 표시 (실패 시)
```

**참고:** 기기 연결은 WebSocket을 통해 Jetson과의 연결 상태를 지속적으로 감지합니다.

**API 요약:**
1. `POST /api/register/step1/` - 기본 정보 등록
2. `POST /api/email/send-code` - 이메일 인증 코드 발송
3. `POST /api/email/verify` - 이메일 인증 코드 확인

---

#### 2.3.3 Step 2: 사용자 등록 (얼굴 등록)

**화면:** 사용자 등록 화면

**페이지 전환:**
- 얼굴 원본 이미지 Jetson 전송 및 벡터화 완료 시 1초 후 자동으로 음성 등록 화면으로 이동

**동작 흐름:**
1. 상태 메시지: "얼굴 이미지 캡처 중..."
2. 앱 카메라 자동 활성화 및 얼굴 스캔 시작
3. 안내 메시지: "얼굴을 중앙에 맞춰주세요", "인식 중입니다..."
4. 10초 내 얼굴 이미지 캡처 완료
5. 앱에서 얼굴 원본 이미지를 Jetson의 HTTP 엔드포인트로 전송 (http://192.168.x.x:8000/register/upload)
6. Jetson에서 로컬 임베딩 연산 수행 (얼굴 벡터 추출, 512-dim)
7. Jetson에서 추출된 벡터 데이터를 EC2 서버로 전송
8. EC2 서버에서 벡터 데이터를 캐시에 임시 저장
9. "사용자 등록 완료!" 메시지
10. 1초 후 음성 등록 화면으로 자동 이동

**Timeout 설정:** 10초
- 10초간 얼굴 인식 실패 시 에러 메시지 표시
- 재시도 버튼 표시

**얼굴 이미지 사양:**
- **형식:** JPEG 또는 PNG
- **최대 크기:** 5MB
- **해상도:** 최소 640x480

**얼굴 벡터 사양 (Jetson 벡터화):**
- **차원:** 512-dim
- **값 범위:** [-1.0, 1.0]
- **형식:** JSON 배열

**Jetson HTTP 엔드포인트:**
- **URL:** `http://192.168.x.x:8000/register/upload`
- **Method:** POST
- **Request:** FormData `{ face_image: File }`
- **Response:** `{ "success": true, "face_vector": [0.123, -0.456, ...] }`

**사용자 등록 실패 시 에러 메시지:**
- "얼굴이 너무 어둡습니다"
- "여러 얼굴이 감지되었습니다"
- "얼굴이 화면 중앙에 오지 않았습니다"
- **UX 요구사항:** 에러 메시지 표시 후 재시도 버튼 클릭 시 다시 스캔 시작

**데이터 흐름:**
```
[앱] 카메라 활성화
  ↓ 얼굴 스캔 (10초)
  ↓ 얼굴 이미지 캡처 (JPEG/PNG, 최대 5MB)
  ↓ POST http://192.168.x.x:8000/register/upload (FormData multipart/form-data: face_image)
[Jetson] 
  ↓ 얼굴 이미지 수신
  ↓ 로컬 임베딩 연산 수행 (얼굴 벡터 추출, 512-dim)
  ↓ 벡터화 완료
  ↓ POST /api/register/face-vector (face_vector: JSON array)
[서버] 
  ↓ 벡터 데이터 수신
  ↓ 캐시에 벡터 임시 저장 (Key: signup:temp:{uuid}, field: face_vector)
  ↓ 응답: { "success": true, "data": { "message": "얼굴 벡터화 완료" } }
[앱] "사용자 등록 완료!" 메시지 표시
  ↓ 1초 후 음성 등록 화면으로 자동 이동
```

**참고:**
- **앱:** 얼굴 원본 이미지를 수집하여 Jetson HTTP 엔드포인트로 전송
- **Jetson:** 얼굴 이미지 벡터화 담당 (로컬 임베딩 연산)
- **서버:** 벡터 데이터만 캐시에 임시 저장

**API 요약:**
1. `POST http://192.168.x.x:8000/register/upload` - 얼굴 원본 이미지 Jetson 전송 및 벡터화 요청
   - Request: FormData `{ face_image: File }`
   - Response (성공): `{ "success": true, "face_vector": [0.123, -0.456, ...] }`
   - **Timeout:** 5초

2. `POST /api/register/face-vector` - Jetson에서 추출된 벡터 데이터 EC2 전송
   - Request: `{ "face_vector": [0.123, -0.456, ...] }`
   - Response (성공): `{ "success": true, "data": { "message": "얼굴 벡터화 완료" } }`
   - **Timeout:** 2초

---

#### 2.3.4 Step 3: 음성 등록 (선택사항)

**화면:** 음성 등록 화면

**페이지 전환:**
- 음성 등록 완료 시 1초 후 자동으로 제어 메인 화면으로 이동
- 건너뛰기 클릭 시 즉시 제어 메인 화면으로 이동

**동작 흐름:**
1. "음성 등록 시작" 버튼 클릭
2. 음성 등록 문장 예시 표시: "SARVIS를 불러보세요"
3. "녹음 중..." 메시지 + 실시간 파형 애니메이션
4. 인식 완료 시 "인식 성공!" 후 필요할 때까지 반복
5. 음성 벡터 수집 진행률 표시 (예: 33% → 66% → 100%)
6. 충분한 음성 원본 오디오 수집 완료
7. 음성 원본 오디오를 Jetson의 HTTP 엔드포인트로 전송 (http://192.168.x.x:8000/register/upload)
8. Jetson에서 로컬 임베딩 연산 수행 (음성 벡터 추출, 256-dim)
9. Jetson에서 추출된 벡터 데이터를 EC2 서버로 전송
10. EC2 서버에서 벡터 데이터를 캐시에 임시 저장
11. "음성 등록 완료!" 메시지
12. 1초 후 제어 메인 화면으로 자동 이동

**음성 오디오 사양:**
- **형식:** WAV 또는 MP3
- **최대 크기:** 10MB
- **샘플레이트:** 16kHz
- **비트레이트:** 128kbps

**음성 벡터 사양 (Jetson 벡터화):**
- **차원:** 256-dim
- **값 범위:** [-1.0, 1.0]
- **형식:** JSON 배열

**Jetson HTTP 엔드포인트:**
- **URL:** `http://192.168.x.x:8000/register/upload`
- **Method:** POST
- **Request:** FormData `{ voice_audio: File }`
- **Response:** `{ "success": true, "voice_vector": [0.123, -0.456, ...] }`

**음성 인식 실패 시:**
- **Timeout 설정:** 3초 안에 "SARVIS"를 인식하지 못했을 시 인식 실패
- "인식 실패!" 후 필요할 때까지 "녹음 중..." 반복
- **UX 요구사항:** 인식 실패 시 자동으로 재시도, 성공할 때까지 반복

**음성 등록 취소:**
- "등록 취소" 버튼 클릭
- "음성 등록을 취소하시겠습니까?" 확인 팝업
- 확인 시 이전 단계로 복귀

**음성 등록 건너뛰기:**
- "건너뛰기" 버튼 클릭
- "음성 명령 기능을 사용할 수 없습니다. 나중에 설정에서 등록할 수 있습니다." 안내
- 확인 시 바로 제어 메인 화면으로 이동
- 음성 벡터는 null로 서버에 저장

**데이터 흐름:**
```
[앱] 음성 등록 화면 표시 중
  ↓ 마이크 활성화
  ↓ 음성 수집 시작
  ↓ "SARVIS" 인식 (3초 Timeout)
  ↓ 인식 성공 시 음성 오디오 캡처 (WAV/MP3, 최대 10MB)
  ↓ 진행률 33% → 66% → 100%
  ↓ 충분한 음성 원본 오디오 수집 완료
  ↓ POST http://192.168.x.x:8000/register/upload (FormData multipart/form-data: voice_audio)
[Jetson] 
  ↓ 음성 오디오 수신
  ↓ 로컬 임베딩 연산 수행 (음성 벡터 추출, 256-dim)
  ↓ 벡터화 완료
  ↓ POST /api/register/voice-vector (voice_vector: JSON array)
[서버] 
  ↓ 벡터 데이터 수신
  ↓ 캐시에 벡터 임시 저장 (Key: signup:temp:{uuid}, field: voice_vector)
  ↓ 응답: { "success": true, "data": { "message": "음성 벡터화 완료" } }
[앱] "음성 등록 완료!" 메시지 표시
  ↓ 1초 후 제어 메인 화면으로 자동 이동
```

**참고:**
- **앱:** 음성 원본 오디오를 수집하여 Jetson HTTP 엔드포인트로 전송
- **Jetson:** 음성 오디오 벡터화 담당 (로컬 임베딩 연산)
- **서버:** 벡터 데이터만 캐시에 임시 저장

**Jetson HTTP 엔드포인트:**
- **URL:** `http://192.168.x.x:8000/register/upload`
- **Method:** POST
- **Request:** FormData `{ voice_audio: File }`
- **Response:** `{ "success": true, "voice_vector": [0.123, -0.456, ...] }`

**API 요약:**
1. `POST http://192.168.x.x:8000/register/upload` - 음성 원본 오디오 Jetson 전송 및 벡터화 요청
   - Request: FormData `{ voice_audio: File }`
   - Response (성공): `{ "success": true, "voice_vector": [0.123, -0.456, ...] }`
   - **Timeout:** 5초

2. `POST /api/register/voice-vector` - Jetson에서 추출된 벡터 데이터 EC2 전송
   - Request: `{ "voice_vector": [0.123, -0.456, ...] }`
   - Response (성공): `{ "success": true, "data": { "message": "음성 벡터화 완료" } }`
   - **Timeout:** 2초

---

#### 2.3.5 회원가입 완료

**화면:** 제어 메인 화면

**페이지 전환:**
- 음성 등록 완료 또는 건너뛰기 후 제어 메인 화면으로 이동

**동작 흐름:**
1. 음성 등록 완료 또는 건너뛰기
2. POST /api/register/complete/ 호출
3. 서버에서 Redis 캐시에서 임시 데이터 조회
4. User 생성 (login_id, password, email, nickname, face_vector, voice_vector)
5. UserDeviceConnection 생성 (user_id, device_id, device_alias)
6. Session 생성 (user_id, connection_id)
7. JWT 토큰 생성
8. 캐시 삭제
9. 앱에 JWT 토큰 전송
10. 제어 메인 화면으로 이동

**데이터 흐름:**
```
[앱] 음성 등록 완료 또는 건너뛰기
  ↓ POST /api/register/complete/ (uuid)
[서버] 
  ↓ Redis 캐시에서 uuid로 사용자 정보 조회
  ↓ User 생성 (login_id, password, email, nickname, face_vector, voice_vector)
  ↓ UserDeviceConnection 생성 (user_id, device_id, device_alias)
  ↓ Session 생성 (user_id, connection_id)
  ↓ JWT 토큰 생성
  ↓ 캐시 삭제
  ↓ 응답: { "success": true, "data": { "user_id": 1, "token": "...", "user": {...}, "session_id": 1 } }
[앱] JWT 토큰 저장
  ↓ "회원가입 완료!" 메시지
  ↓ 제어 메인 화면으로 이동
```

**API 요약:**
1. `POST /api/register/complete/` - 회원가입 완료
   - Request: `{ "uuid": "..." }`
   - Response (성공): `{ "success": true, "data": { "user_id": 1, "token": "...", "user": {...}, "session_id": 1 } }`
   - **Timeout:** 3초

---

### 2.4 데이터 모델

**관련 모델:**
- User
- UserDeviceConnection
- BiometricLog

**필드 관계:**
```
User (1) → UserDeviceConnection (N)
User (1) → BiometricLog (N)
```

---

### 2.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| 기본 정보 등록 | POST | `/api/register/step1/` | 닉네임, 아이디, 비밀번호, 이메일 등록 | 2초 |
| 이메일 인증 코드 전송 | POST | `/api/email/send-code` | 이메일로 인증 코드 발송 | 3초 |
| 이메일 인증 코드 확인 | POST | `/api/email/verify` | 인증 코드 확인 | 1초 |
| 얼굴 이미지 업로드 및 벡터화 | POST | `http://192.168.x.x:8000/register/upload` | 얼굴 원본 이미지 Jetson 전송 및 벡터화 | 5초 |
| 음성 오디오 업로드 및 벡터화 | POST | `http://192.168.x.x:8000/register/upload` | 음성 원본 오디오 Jetson 전송 및 벡터화 | 5초 |
| 회원가입 완료 | POST | `/api/register/complete/` | UUID, 얼굴/음성 벡터 저장 및 회원가입 완료 | 3초 |

---

### 2.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| 아이디 중복 | 409 | USER_ALREADY_EXISTS | "이미 사용 중인 아이디입니다." | 아이디 재입력 요청 |
| 이메일 중복 | 409 | USER_ALREADY_EXISTS | "이미 사용 중인 이메일입니다." | 이메일 재입력 요청 |
| 이메일 인증 코드 불일치 | 400 | INVALID_EMAIL_CODE | "인증 코드가 올바르지 않습니다." | 재입력 요청 |
| 이메일 인증 코드 만료 | 400 | INVALID_EMAIL_CODE | "인증 코드가 만료되었습니다." | 재발송 요청 |
| S3 업로드 실패 | 500 | S3_UPLOAD_FAILED | "파일 업로드에 실패했습니다." | 재시도 요청 |
| EC2 벡터화 실패 | 500 | VECTORIZATION_FAILED | "벡터화에 실패했습니다." | 재시도 요청 |
| 회원가입 완료 실패 | 500 | COMMON_005 | "서버 오류가 발생했습니다." | 재시도 요청 |

---

### 2.7 UX 요구사항

| 항목 | 요구사항 |
|------|----------|
| 입력 필드 | 실시간 유효성 검증 및 피드백 (녹색 체크 또는 빨간색 X) |
| 로딩 상태 | API 요청 시 로딩 스피너 표시 |
| 에러 메시지 | 명확한 에러 원인 및 해결 방법 제시 |
| 버튼 상태 | 조건 충족 시에만 버튼 활성화 |
| 페이지 전환 | 자연스러운 페이지 전환 애니메이션 |
| 진행률 표시 | 음성 등록 진행률 표시 (33% → 66% → 100%) |
| 취소 확인 | 중요 작업 취소 시 확인 팝업 표시 |
| 타이머 | 인증번호 유효기간 타이머 표시 (05:00) |
| 안내 문구 | 명확한 안내 문구 제공 (예: "얼굴을 중앙에 맞춰주세요") |

---

### 2.8 Timeout 설정 요약

| 항목 | Timeout | 설명 |
|------|---------|------|
| 이메일 인증 코드 유효기간 | 5분 (300초) | 인증번호 만료 시간 |
| 인증번호 재발송 대기 | 60초 | 재발송 버튼 활성화 대기 |
| 얼굴 인식 시간 | 10초 | 얼굴 이미지 캡처 시간 |
| 음성 인식 시간 | 3초 | "SARVIS" 인식 Timeout |
| Redis 캐시 TTL | 30분 (1800초) | 회원가입 임시 데이터 만료 시간 |
| Jetson 이미지/오디오 업로드 및 벡터화 | 5초 | 얼굴/음성 원본 파일 업로드 및 벡터화 시간 |

---

### 2.9 보안 요구사항

| 항목 | 요구사항 |
|------|----------|
| 비밀번호 | bcrypt hash로 저장 |
| 이메일 인증 코드 | 5분 TTL |
| 회원가입 임시 데이터 | 30분 TTL (Redis) |
| 원본 파일 처리 | 벡터화 완료 후 즉시 삭제 |
| Jetson HTTP 엔드포인트 보안 | 로컬 네트워크 내 Jetson → 앱 직접 통신 (192.168.x.x) |

---

## 3. 로그인

### 3.1 기능 개요

**목적:** 등록된 사용자가 SARVIS 서비스에 접속하여 모든 기능을 사용할 수 있도록 인증

**필수 구성요소:**
- 로그인 초기 화면
- QR코드 스캔 (최초 연결 시)
- 사용자 목록 화면 (기기 계정 이력 조회)
- 얼굴 스캔 화면 (선택사항, 보안 강화용)
- 로그인 폼 (아이디/비밀번호 또는 이메일/비밀번호)

**선행 조건:**
- 사용자가 앱을 실행하여 로그인 초기 화면에 접속
- 앱 최초 실행 시 접근성 서비스 권한 요청 완료
- 블루투스 연결 (BLE)

**후행 조건:**
- 로그인 성공 후 메인 화면(홈 탭)으로 이동

**인증 방식:**
- **하이브리드 인증:** 블루투스 연결 → 기기 계정 이력 조회 → 사용자 목록 표시 → 사용자 선택 → 얼굴 스캔(선택사항) → 로그인
- **최초 사용:** 사용자 목록 비어있음 → 회원가입 유도 → 로그인
- **대안 로그인:** 얼굴 스캔 실패 시 아이디/비밀번호 또는 이메일/비밀번호 로그인 제공

---

### 3.2 페이지 전환 흐름

```
로그인 초기 화면
    ↓ (블루투스 연결)
기기 계정 이력 조회
    ↓ (사용자 목록 비어있음)
회원가입 유도
    ↓ (회원가입 완료)
제어 메인 - 홈 탭

로그인 초기 화면
    ↓ (블루투스 연결)
기기 계정 이력 조회
    ↓ (사용자 목록 있음)
사용자 목록 화면
    ↓ (사용자 선택)
얼굴 스캔 화면 (선택사항)
    ↓ (얼굴 인식 성공)
제어 메인 - 홈 탭

사용자 목록 화면
    ↓ (얼굴 스캔 실패 3회 또는 건너뛰기)
로그인 폼 (아이디/비밀번호 또는 이메일/비밀번호)
    ↓ (로그인 성공)
제어 메인 - 홈 탭

로그인 초기 화면
    ↓ ("아이디로 로그인" 버튼 클릭)
로그인 폼
    ↓ (로그인 성공)
제어 메인 - 홈 탭

앱 재실행 (JWT 존재)
    ↓ (세션 유효 확인)
제어 메인 - 홈 탭 (자동 로그인)
```

---

### 3.3 상세 흐름 및 데이터 흐름

#### 3.3.1 앱 초기 실행 화면

**화면:** 로그인 초기 화면

**페이지 전환:**
- "SARVIS 시작" 버튼: 얼굴 스캔 화면으로 이동
- "아이디로 로그인" 버튼: 로그인 폼으로 이동
- "회원가입" 버튼: 회원가입 초기 화면으로 이동

**앱 최초 실행 시 권한 요청:**
- **권한 요청 타이밍:** 앱 최초 실행 시
- **권한 안내 팝업:**
  - 메시지: "유튜브 조작을 위해 접근성 권한이 필요합니다."
  - 설명: "SARVIS 앱이 유튜브와 같은 다른 앱을 제어하려면 시스템 설정에서 접근성 권한을 허용해야 합니다."
  - "설정하러 가기" 버튼 클릭 → 안드로이드 시스템 접근성 설정 화면으로 이동
- 사용자가 SARVIS 서비스를 '허용'으로 전환 후 앱으로 복귀

**자동 로그인 체크:**
- 앱 실행 시 로컬 스토리지에 저장된 JWT 존재 여부 확인
- 세션 존재 시 `GET /api/sessions/current` 호출
  - **Timeout 설정:** 2초
- 유효한 세션 시 바로 제어 메인 화면으로 이동

**기기 연결 감지 로직 (상세):**
- **기기-서버 연결:** Jetson은 항상 서버와 WebSocket 연결 유지 (무선 통신, Cloud 서버)
- **앱-서버 연결:** 앱은 HTTPS/WSS로 서버와 연결
- **앱-Jetson 연결:** 앱은 Jetson WebSocket URL로 연결 (최초 연결 시 QR코드 스캔으로 URL 획득, 이후에는 저장된 URL 사용)
- **앱 시작 시 자동 연결 시도:**
  1. 앱 실행 시 로컬 스토리지에 저장된 Jetson IP 확인 (192.168.x.x)
  2. HTTP 연결 시도로 연결 상태 확인
  3. **상태 분기:**
     - **"현재 기기 연결됨"**: 기존 연결 유지, 로그인 성공 시 그대로 사용 가능
     - **"기기 연결 시도"**: 신규 연결 프로세스 시작

**상태 표시:**
- **"현재 기기 연결됨" (녹색 점):** WebSocket 연결 완료 상태
- **"기기 연결 시도" (회색 점):** 연결 대기 상태

**상단 인디케이터 (모든 화면 공통):**
- **위치:** 화면 상단에 항상 표시
- **상태 표시:**
  - "기기 연결 대기중..." (회색 점) - WebSocket 연결 대기 중
  - "기기가 연결 되었습니다." (녹색 점) - WebSocket 연결 완료

- **WebSocket 연결 감지 로직:**
  - 앱 시작 시 자동 Jetson WebSocket 연결 시도
  - 연결 확인: WebSocket 메시지 핸드셰이크를 통해 Jetson 식별 정보 확인
  - 연결 끊김 감지: WebSocket 연결 끊김 이벤트 리스너를 통해 즉시 감지

**기기 연결 끊김 처리 (모든 화면 공통):**
- 감지: WebSocket 연결 끊김 감지
- 메시지: "기기가 연결되지 않았습니다. 기기를 연결해주세요."
- 오버레이: 화면 전체에 반투명 오버레이(Opacity 0.5) 적용
- 터치 비활성화: 모든 컴포넌트의 터치 이벤트 비활성화
- 세션 유예: 연결 해제 시점으로부터 60분 동안만 임시 세션 유효
- 재연결 시: 60분 이내에 재연결될 경우 정상 상태 복귀
- 세션 만료: 60분 경과 시 세션 즉시 만료 후 로그인 초기 화면으로 강제 이동

**초기 상태 구성요소:**
- 브랜딩 영역: SARVIS 로고 및 "Smart Assistance Robot" 태그라인
- **SARVIS 시작** 버튼: 얼굴 인식을 통한 자동 로그인
- **"아이디로 로그인"/"회원가입" 버튼:** 하단에 연한 글씨로 작게

**푸터 정보:**
- Copyright: © 2026 Team S.A.R.V.I.S. All rights reserved.
- License: (추후 설정 예정)
- Links: 이용약관 | 개인정보 처리방침 | [GitLab](https://lab.ssafy.com/s14-webmobile3-sub1/S14P11A104)

---

#### 3.3.2 QR코드 스캔 (최초 연결 시)

**화면:** QR코드 스캔 화면

**페이지 전환:**
- QR코드 스캔 → 기기 계정 이력 조회

**동작 흐름:**
1. 앱이 Jetson WebSocket URL이 없음을 확인
2. QR코드 스캔 화면으로 이동
3. QR코드 스캔 (Jetson 장치의 QR 코드)
4. QR코드 인증 (Jetson 서버 URL 및 기기 ID 획득)
5. Jetson WebSocket URL 및 기기 ID 로컬 저장
6. Jetson WebSocket 연결 시도
7. 연결 성공 시 "기기가 연결되었습니다." 메시지
8. 기기 계정 이력 조회

**QR코드 포맷:**
- URL: Jetson WebSocket URL (예: `ws://jetson.local:8000/ws`)
- Device ID: Jetson 기기 식별자 (예: `JETSON-001`)

**데이터 흐름:**
```
[앱] QR코드 스캔
  ↓ QR 코드 파싱
  ↓ POST /api/auth/qr-login (qr_data)
[서버]
  ↓ QR코드 인증
  ↓ Jetson WebSocket URL 및 Device ID 반환
  ↓ 응답: { "success": true, "data": { "jetson_url": "...", "device_id": "..." } }
[앱] Jetson WebSocket URL 및 Device ID 저장
  ↓ Jetson WebSocket 연결 시도
[Jetson] WebSocket 연결 수신
  ↓ "기기가 연결되었습니다." 메시지
[앱] 기기 프리셋 설정 화면으로 이동
```

**API 요약:**
1. `POST /api/auth/qr-login` - QR코드 로그인
   - Request: `{ "qr_data": "..." }`
   - Response (성공): `{ "success": true, "data": { "jetson_url": "...", "device_id": "..." } }`
   - **Timeout:** 3초

---

#### 3.3.3 사용자 목록 화면

**화면:** 사용자 목록 화면

**페이지 전환:**
- 기기 계정 이력 조회 후 사용자 목록 화면으로 이동

**동작 흐름:**
1. 기기에 등록된 UserDeviceConnection 목록 조회
2. 사용자 목록 표시 (닉네임, 최근 사용 시간)
3. 사용자 선택
4. 선택된 사용자의 얼굴 스캔 (선택사항, 보안 강화용)
5. 얼굴 인식 성공 시 로그인 완료
6. 얼굴 인식 실패 시 대안 로그인 제공 (아이디/비밀번호 또는 이메일/비밀번호)

**사용자 목록 예시:**
```
사용자 선택:
- 아빠 (최근 사용: 2시간 전)
- 엄마 (최근 사용: 5시간 전)
- 첫째 (최근 사용: 1일 전)
```

**데이터 흐름:**
```
[앱] 기기 계정 이력 조회
  ↓ GET /api/devices/{device_id}/users
[서버] 
  ↓ 기기에 등록된 UserDeviceConnection 목록 조회
  ↓ 응답: { "success": true, "data": [{ "user_id": 1, "nickname": "아빠", "last_connected": "..." }, ...] }
[앱] 사용자 목록 표시
  ↓ 사용자 선택
  ↓ 얼굴 스캔 (선택사항) 또는 대안 로그인
```

**API 요약:**
1. `GET /api/devices/{device_id}/users` - 기기에 등록된 사용자 목록 조회
   - Response (성공): `{ "success": true, "data": [{ "user_id": 1, "nickname": "아빠", "last_connected": "..." }, ...] }`
   - **Timeout:** 2초

**UX 요구사항:**
- 사용자 목록에 닉네임과 최근 사용 시간 표시
- 사용자 선택 시 즉시 피드백 제공
- 얼굴 스캔 선택사항: 설정에서 켜기/끄기 가능

---

#### 3.3.4 얼굴 인식 로그인 (사용자 선택 후)

**화면:** 사용자 목록 화면 → 얼굴 스캔 화면

**페이지 전환:**
- 얼굴 인식 성공 시 메인 화면으로 이동
- 얼굴 인식 실패 3회 시 대안 로그인 제공

**실행 흐름:**
1. 사용자가 사용자 목록에서 사용자 선택
2. 선택된 사용자의 얼굴로 추가 인증 (선택사항, 보안 강화용)
3. 카메라 자동 활성화 (3초간 스캔)
4. 얼굴 스캔 진행 중 안내 메시지 표시: "얼굴을 중앙에 맞춰주세요", "조명을 밝게 해주세요"
5. 얼굴 이미지 캡처 완료
6. 얼굴 원본 이미지를 Jetson의 HTTP 엔드포인트로 전송 (http://192.168.x.x:8000/auth/face-verify)
7. Jetson이 로컬 임베딩 연산 수행 (얼굴 벡터 추출, 512-dim)
8. 서버에서 벡터 매칭 및 사용자 인증
9. 얼굴 인식 성공 시 "사용자 인식 완료!" 메시지
10. 자동으로 메인 화면(홈탭)으로 이동

**Timeout 설정:** 3초
- 얼굴 스캔 3초 Timeout

**얼굴 스캔 실패:**
- 첫 번째 실패(3초간 스캔 실패): "얼굴 스캔 재시도" 버튼 노출
- 첫 시도 포함 3회 실패 시: 대안 로그인 제공 (아이디/비밀번호 또는 이메일/비밀번호)

**스캔 중 취소:**
- "스캔 중지" 버튼 클릭
- "스캔을 중단하시겠습니까?" 확인 팝업
- 확인 시 사용자 목록 화면으로 복귀

**얼굴 이미지 사양:**
- **형식:** JPEG 또는 PNG
- **최대 크기:** 5MB
- **해상도:** 최소 640x480

**얼굴 벡터 사양 (Jetson 벡터화):**
- **차원:** 512-dim
- **값 범위:** [-1.0, 1.0]
- **형식:** JSON 배열

**Jetson HTTP 엔드포인트:**
- **URL:** `http://192.168.x.x:8000/auth/face-verify`
- **Method:** POST
- **Request:** FormData `{ user_id: 1, face_image: File }`
- **Response:** `{ "success": true, "face_vector": [0.123, -0.456, ...] }`

**데이터 흐름:**
```
[앱] 사용자 목록에서 사용자 선택
  ↓ 선택된 사용자의 얼굴 스캔 (선택사항)
  ↓ 카메라 활성화
  ↓ 얼굴 스캔 (3초)
  ↓ 얼굴 이미지 캡처 (JPEG/PNG, 최대 5MB)
  ↓ POST http://192.168.x.x:8000/auth/face-verify (FormData multipart/form-data: user_id, face_image)
[Jetson] 
  ↓ 얼굴 이미지 수신
  ↓ 로컬 임베딩 연산 수행 (얼굴 벡터 추출, 512-dim)
  ↓ 벡터화 완료
  ↓ POST /api/auth/face-verify (face_vector: JSON array)
[서버] 
  ↓ 벡터 데이터 수신
  ↓ User.face_vector와 코사인 유사도 계산
  ↓ threshold: 0.48 이상일 때 일치 판정
  ↓ JWT 토큰 생성
  ↓ Session 생성
  ↓ 응답: { "success": true, "data": { "user_id": 1, "token": "...", "user": {...}, "session_id": 1 } }
[Jetson → 앱] 응답: { "success": true, "face_vector": [0.123, -0.456, ...] }
[앱] JWT 토큰 저장
  ↓ "사용자 인식 완료!" 메시지
  ↓ 제어 메인 화면으로 이동

**매칭 실패 시:**
[서버] 벡터 매칭 실패
  ↓ 응답: { "success": false, "error": "FACE_VERIFY_FAILED" }
[앱] "얼굴 인식에 실패했습니다. 다른 방법으로 로그인해주세요." 메시지
  ↓ 대안 로그인 제공 (아이디/비밀번호 또는 이메일/비밀번호)
```

**참고:**
- **앱:** 얼굴 원본 이미지를 수집하여 Jetson HTTP 엔드포인트로 전송
- **Jetson:** 얼굴 이미지 벡터화 담당 (로컬 임베딩 연산)
- **서버:** 벡터 매칭 및 사용자 인증 담당

**API 요약:**
1. `POST http://192.168.x.x:8000/auth/face-verify` - 얼굴 원본 이미지 Jetson 전송 및 벡터화 요청
   - Request: FormData `{ user_id: 1, face_image: File }`
   - Response (성공): `{ "success": true, "face_vector": [0.123, -0.456, ...] }`
   - **Timeout:** 5초

2. `POST /api/auth/face-verify` - Jetson에서 추출된 벡터 데이터 EC2 전송 및 인증
   - Request: `{ "face_vector": [0.123, -0.456, ...] }`
   - Response (성공): `{ "success": true, "data": { "user_id": 1, "token": "...", "user": {...}, "session_id": 1 } }`
   - Response (실패): `{ "success": false, "error": "FACE_VERIFY_FAILED" }`
   - 벡터 매칭: 코사인 유사도 (Cosine Similarity), threshold: 0.48
   - **Timeout:** 3초

**UX 요구사항:**
- 얼굴 스캔 선택사항: 설정에서 켜기/끄기 가능
- 얼굴 스캔 실패 시 대안 로그인 제공
- 로딩 스피너 및 안내 메시지 표시

---

#### 3.3.5 아이디/비밀번호 또는 이메일/비밀번호 로그인 (대안 로그인)

**화면:** 로그인 폼

**페이지 전환:**
- 얼굴 스캔 실패 3회 시 대안 로그인 제공
- 로그인 성공 시 메인 화면으로 이동

**실행 흐름:**
1. 사용자가 아이디/비밀번호 또는 이메일/비밀번호로 로그인 선택
2. 아이디 또는 이메일 입력
3. 비밀번호 입력
4. "로그인" 버튼 클릭
5. 로그인 성공 시 메인 화면으로 이동

**로그인 실패 (오류):**
- "아이디 또는 비밀번호가 올바르지 않습니다." 메시지
- 입력 필드 빨간색 테두리 표시

**필수 정보 미입력:**
- "아이디와 비밀번호를 입력해주세요." 메시지
- 미입력 필드에 포커스 이동

**회원가입 버튼:** 하단 회원가입 버튼을 통해 회원가입 페이지로 이동 가능

**데이터 흐름:**
```
[앱] 아이디 또는 이메일, 비밀번호 입력
  ↓ POST /api/auth/login (login_id 또는 email, password)
[서버] 
  ↓ User.login_id 또는 User.email로 사용자 조회
  ↓ 해당 User의 UUID 확인
  ↓ bcrypt로 비밀번호 검증
  ↓ 조회된 UUID를 사용하여 JWT 토큰 생성
  ↓ Session 생성 (user_id)
[앱] JWT 토큰 저장
  ↓ 제어 메인 화면으로 이동
```

**API 요약:**
1. `POST /api/auth/login` - 아이디/비밀번호 또는 이메일/비밀번호 로그인
   - Request: `{ "login_id": "dae_lee", "password": "Secure123!" }` 또는 `{ "email": "dae_lee@example.com", "password": "Secure123!" }`
   - Response (성공): `{ "success": true, "data": { "user_id": 1, "token": "...", "user": {...}, "session_id": 1 } }`
   - **Timeout:** 2초

**UX 요구사항:**
- 아이디/이메일 선택 드롭다운 제공
- 로딩 스피너 및 에러 메시지 표시

---

#### 3.3.6 자동 로그인 (세션 유지)

**페이지 전환:**
- 앱 재실행 시 로컬 스토리지에 저장된 JWT 존재 여부 확인
- 세션 유효 시 바로 제어 메인 화면(홈탭) 표시

**실행 흐름:**
1. 앱 재실행 시 로컬 스토리지에 저장된 JWT 존재 여부 확인
2. Jetson WebSocket 연결 확인
3. 세션 유효 시 자동 로그인 진행
4. 바로 메인 화면(홈탭) 표시

**WebSocket 연결 중:**
- 서버와의 주기적인 Heartbeat 통신 (10초 간격)을 통해 JWT 만료를 유예하며, 
연결이 지속되는 한 세션을 실시간 갱신하여 무제한 유지한다.

**WebSocket 연결 끊김:**
- WebSocket 연결 끊김 감지
- "기기가 연결되지 않았습니다. 기기를 연결해주세요." 메시지
- 연결 해제 시점을 기준으로 60분의 유예 시간을 카운트다운한다.
- 메인 화면 전체에 반투명 오버레이(Opacity 0.5) 적용 및 컴포넌트의 터치 이벤트 비활성화
- 연결 해제 시점으로부터 60분 동안만 유효한 임시 세션 부여한다.

**세션 만료 조건:**
1. WebSocket 미연결 상태에서 60분이 경과한 경우
2. 서버로부터 401 Unauthorized 응답을 받은 경우
3. JWT 토큰 만료 시간 (기본 24시간) 경과 후 연결이 끊긴 경우
- "세션이 만료되었습니다. 다시 로그인해주세요." 안내 메시지 표시
- 로컬에 저장된 모든 토큰 정보 삭제 및 로그인 초기 화면으로 강제 이동
- 로그인 초기 화면으로 이동

**데이터 흐름:**
```
[앱] 앱 재실행
  ↓ 로컬 스토리지에서 JWT 확인
  ↓ GET /api/sessions/current (Header: Authorization: Bearer {jwt_token})
[서버] 
  ↓ JWT 토큰 검증
  ↓ Session 조회
  ↓ connection_status 확인 (CONNECTED, GRACE_PERIOD, EXPIRED)
[앱] 
  ↓ CONNECTED 또는 GRACE_PERIOD: 제어 메인 화면 표시
  ↓ EXPIRED: 로그인 초기 화면으로 이동

[Heartbeat] 10초 간격 (WebSocket)
  ↓ WebSocket 메시지: { "type": "heartbeat", "session_id": 1 }
[서버] 
  ↓ JWT 만료 시간 갱신
  ↓ connection_status 업데이트
  ↓ WebSocket 응답: { "type": "heartbeat_response", "status": "ok" }
[앱] 세션 상태 수신
  ↓ 세션 유효 시 계속 사용
  ↓ 세션 만료 시 로그인 초기 화면으로 이동
```

**API 요약:**
1. `GET /api/sessions/current` - 현재 세션 확인
   - Header: `Authorization: Bearer {jwt_token}`
   - Response (성공): `{ "success": true, "data": { "session_id": 1, "user_id": 1, "user": {...}, "connection_id": 1, "robot_status": "IDLE" }`
   - **Timeout:** 2초

---

### 3.4 데이터 모델

**관련 모델:**
- User
- Session
- UserDeviceConnection

**필드 관계:**
```
User (1) → Session (N)
User (1) → UserDeviceConnection (N)
Device (1) → Session (N)
```

---

### 3.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| QR코드 로그인 | POST | `/api/auth/qr-login` | QR코드 스캔으로 Jetson 서버 URL 획득 | 3초 |
| 기기 사용자 목록 조회 | GET | `/api/devices/{device_id}/users` | 기기에 등록된 사용자 목록 조회 | 2초 |
| 얼굴 인증 | POST | `/api/auth/face-verify` | 사용자 선택 후 얼굴 스캔으로 인증 | 5초 |
| 아이디/비밀번호 로그인 | POST | `/api/auth/login` | 아이디/비밀번호 또는 이메일/비밀번호로 로그인 | 2초 |
| 현재 세션 확인 | GET | `/api/sessions/current` | 현재 세션 확인 | 2초 |

---

### 3.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| 아이디 또는 비밀번호 불일치 | 401 | INVALID_CREDENTIALS | "아이디 또는 비밀번호가 올바르지 않습니다." | 재입력 요청 |
| 얼굴 벡터 매칭 실패 | 404 | USER_NOT_FOUND | "사용자를 찾을 수 없습니다." | 수동 로그인 유도 |
| 얼굴 인증 실패 | 401 | FACE_VERIFY_FAILED | "얼굴 인식에 실패했습니다. 다른 방법으로 로그인해주세요." | 대안 로그인 유도 |
| 세션 만료 | 401 | SESSION_EXPIRED | "세션이 만료되었습니다. 다시 로그인해주세요." | 재로그인 요청 |
| 유효하지 않은 토큰 | 401 | INVALID_TOKEN | "유효하지 않거나 만료된 토큰입니다." | 재로그인 요청 |
| S3 업로드 실패 | 500 | S3_UPLOAD_FAILED | "파일 업로드에 실패했습니다." | 재시도 요청 |
| EC2 벡터화 실패 | 500 | VECTORIZATION_FAILED | "벡터화에 실패했습니다." | 재시도 요청 |

---

### 3.7 UX 요구사항

| 항목 | 요구사항 |
|------|----------|
| 로딩 상태 | 로그인 요청 시 로딩 스피너 표시 |
| 에러 메시지 | 명확한 에러 원인 및 해결 방법 제시 |
| 입력 필드 | 에러 시 빨간색 테두리 표시 |
| 얼굴 스캔 안내 | "얼굴을 중앙에 맞춰주세요", "조명을 밝게 해주세요" 안내 메시지 |
| 자동 로그인 | 로딩 없이 자연스럽게 메인 화면으로 이동 |
| 기기 연결 인디케이터 | 항상 상단에 연결 상태 표시 (녹색/빨간색) |

---

### 3.8 Timeout 설정 요약

| 항목 | Timeout | 설명 |
|------|---------|------|
| QR코드 인증 | 3초 | QR코드 인증 시간 |
| 얼굴 스캔 Timeout | 3초 | 얼굴 스캔 시간 |
| API 요청 Timeout | 2초 | 아이디 로그인, 세션 확인 |
| 얼굴 로그인 Timeout | 5초 | 얼굴 이미지 Jetson 전송 및 EC2 벡터화 포함 |
| Heartbeat 주기 | 10초 | 세션 갱신 주기 (WebSocket) |
| JWT 만료 시간 | 24시간 | 기본 토큰 만료 시간 |
| 세션 유예 시간 | 60분 | WebSocket 연결 해제 후 임시 세션 유효 시간 |

---

### 3.9 보안 요구사항

| 항목 | 요구사항 |
|------|----------|
| 비밀번호 | bcrypt hash로 저장 및 검증 |
| JWT 토큰 | HS256 알고리즘으로 서명 |
| 토큰 만료 시간 | 24시간 (기본) |
| 얼굴 벡터 매칭 | 코사인 유사도 0.48 이상 |
| Heartbeat 주기 | 10초 (WebSocket) |
| 원본 파일 처리 | 벡터화 완료 후 즉시 삭제 |
| Jetson HTTP 엔드포인트 보안 | 로컬 네트워크 내 Jetson → 앱 직접 통신 (192.168.x.x)

---

## 4. 로봇 제어

### 4.1 기능 개요

**목적:** 사용자가 음성 명령 또는 수동 제어를 통해 로봇을 제어

**필수 구성요소:**
- 음성 명령 제어 (자동, Jetson 처리)
- 빠른 제어 버튼 (따라와, 시야 밖으로 이동, 이리 와)
- 수동 제어 패널 (위치 이동, 거리 조절, 회전 제어)

**선행 조건:**
- 사용자가 로그인에 성공
- WebSocket 연결 되어 있어야 함

**후행 조건:**
- 로봇 상태 업데이트
- UI 업데이트 (로봇 상태 표시)

---

### 4.2 페이지 전환 흐름

```
메인 페이지 - 홈 탭
    ↓ (음성 명령 또는 빠른 제어 버튼 클릭)
로봇 제어 명령 실행
    ↓ (명령 완료)
로봇 상태 업데이트

메인 페이지- 제어 탭
    ↓ (수동 제어 버튼 클릭)
로봇 제어 명령 실행
    ↓ (명령 완료)
로봇 상태 업데이트
```

---

### 4.3 상세 흐름 및 데이터 흐름

#### 4.3.1 음성 명령 제어

**화면:** 홈 탭

**페이지 전환:**
페이지 전환 없음, 실시간 음성 명령 처리

**동작 흐름:**
1. Jetson 마이크에서 음성("SARVIS") 인식 (음성 인식 엔진)
2. 텍스트 수신 및 명령 파싱
3. 기존 명령 중지, 새 명령 실행
4. 명령 완료 후 텍스트 초기화
5. 2초 동안 음성 인식이 없을 경우 자동으로 타임아웃 처리 후 "듣고 있습니다..." 상태로 복귀

**음성 명령 예시:**
- "따라와": 로봇 상태 "추적 중" (녹색)
- "이리와": 로봇 상태 "이동 중" (파란색)
- "멈춰": 로봇 즉시 정지 → "대기 중" (회색)
- "저리 가": 로봇 상태 "이동 중" (파란색)
- "왼쪽으로": 로봇 상태 "이동 중" (파란색)(left로 1 step만큼 이동)
- "오른쪽으로": 로봇 상태 "이동 중" (파란색)(right로 1 step만큼 이동)
- "위로": 로봇 상태 "이동 중" (파란색)(up으로 1 step만큼 이동)
- "아래로": 로봇 상태 "이동 중" (파란색)(down으로 1 step만큼 이동)
- "가까이": 로봇 상태 "이동 중" (파란색)(distance -1 step만큼 이동)
- "멀리": 로봇 상태 "이동 중" (파란색)(distance 1 step만큼 이동)
- "음성 인식 타임아웃:**
- 2초 동안 음성 입력이 없을 경우 자동으로 타임아웃 처리 후 "듣고 있습니다..."로 복귀

**음성 인식 실패:**
- "다시 말씀해주세요" 메시지
- 0.5초 후 "듣고 있습니다..."로 복귀

**음성 인식 타임아웃:**
- 2초 동안 음성 입력이 없을 경우 자동 타임아웃
- 실시간 인식 텍스트 초기화
- "듣고 있습니다..." 상태로 복귀

**데이터 흐름:**
```
[Jetson] 마이크 (2개)에서 음성 수집
  ↓ 음성 인식 엔진
  ↓ 텍스트 변환
  ↓ 명령 파싱
[Jetson] 명령 처리
  ↓ 로봇 제어 신호 생성
  ↓ RPi로 전송 (내부 유선연결)
[RPi] 모터 제어
  ↓ 명령 실행
  ↓ 완료 신호 전송
[Jetson] POST /api/sessions/{session_id}/robot-status (robot_status, last_voice_command)
[서버] Session.robot_status 업데이트
  ↓ Session.last_voice_command 업데이트
[Jetson → 앱] WebSocket 메시지: { "type": "robot_status", "status": "MOVING", "message": "사용자에게 이동 중..." }
[앱] UI 업데이트 (로봇 상태 표시)
```

**UX 요구사항:**
- 실시간 인식된 텍스트 표시 (Jetson에서 앱으로 WebSocket으로 전송)
- 음성 파형 애니메이션 재생
- 명령 완료 후 텍스트 초기화
- 0.5초 후 "듣고 있습니다..."로 복귀

---

#### 4.3.2 빠른 제어 버튼

**화면:** 홈 탭

**페이지 전환:**
페이지 전환 없음, 실시간 버튼 클릭 처리

**따라와 토글:**
1. 토글 on
2. 로봇 상태 "추적 중" (녹색)
3. 토글 off시 "대기 중" (회색)

**시야 밖으로 버튼:**
1. 버튼 클릭
2. 로봇 상태 "시야 밖으로 이동 중" (주황색)
3. 텍스트 "시야 밖으로 이동 중..."
4. 완료 후 "대기 중" (회색)
5. 텍스트 "시야 밖으로 이동 완료"

**이리 와 버튼:**
1. 버튼 클릭
2. 로봇 상태 "이동 중" (파란색)
3. 텍스트 "사용자에게 이동 중..."
4. 완료 후 "대기 중" (회색)
5. 텍스트 "이동 완료"

**멈춰 버튼:**
1. 버튼 클릭
2. 로봇 상태 "시야 밖으로 이동 중" (주황색)
3. 텍스트 "시야 밖으로 이동 중..."
4. 완료 후 "대기 중" (회색)
5. 텍스트 "시야 밖으로 이동 완료"

**데이터 흐름:**
```
[앱] 버튼 클릭
  ↓ WebSocket 메시지: { "type": "robot_command", "command": "come_here" }
[Jetson] WebSocket 메시지 수신
  ↓ 명령 처리
  ↓ RPi로 전송 (내부 유선연결)
[RPi] 모터 제어
  ↓ 명령 실행
  ↓ 완료 신호 전송
[Jetson] POST /api/sessions/{session_id}/robot-status (robot_status)
[서버] Session.robot_status 업데이트
[Jetson → 앱] WebSocket 메시지: { "type": "robot_status", "status": "MOVING" }
[앱] UI 업데이트 (로봇 상태 표시)
```

**UX 요구사항:**
- 버튼 클릭 시 즉시 피드백 제공
- 로봇 상태 텍스트 표시
- 완료 후 메시지 표시

---

#### 4.3.3 수동 제어

**화면:** 제어 탭

**페이지 전환:**
페이지 전환 없음, 제어 탭 내 실시간 제어

**제어 패널 구성:**
- **상태 표시:** 클릭 시 모달, 좌(우) 3, 위(아래) 3, 왼쪽(오른쪽) 각도 0°, 위쪽 각도(아래쪽) 0°, 거리: 5단계
- **위치 이동:** 상, 하, 좌, 우 버튼
- **거리 조절:** 5단계 스텝형 눈금 슬라이더 (가까이 ←→ 멀리)
- **회전 제어:** 좌/우, 상/하 버튼
- **기능 버튼:** 프리셋 저장, 되돌리기

**위치 이동 (상/하/좌/우):**
- **"위쪽 화살표"버튼 클릭:** 로봇 상 방향 1 step 이동, Y -1 (사용자 표기 x)
- **"아래쪽 화살표"버튼 클릭:** Y +1 (사용자 표기 x)
- **"왼쪽 화살표"버튼 클릭:** X -1 (사용자 표기 x)
- **"오른쪽 화살표"버튼 클릭:** X +1 (사용자 표기 x)

**거리 조절:**
- **스텝형 슬라이더 드래그**
- **범위:** 가까이 ←→ 멀리
- **Z 값 변경:** 0, 25, 50, 75, 100 (사용자 표기 x)

**회전 제어 (Tilt/HAS):**
- **"상하제어 ⍐⍗":**
  1. ⍐: 상 방향 3° 회전, Tilt -3° (사용자 표기 x)
- **"하방제어 ⍗":**
  1. ⍗: 하 방향 3° 회전, Tilt +3° (사용자 표기 x)
- **"좌우제어 ⍐⍗":**
  1. ⍇: 좌 방향 3° 회전, HAS -3° (사용자 표기 x)
- **"우로우제어 ⍈":**
  1. ⍈: 우 방향 3° 회전, HAS +3° (사용자 표기 x)

**Timeout 설정:** 200ms
- 기기 응답 시간: 200ms 이내

**데이터 흐름:**
```
[앱] 버튼 클릭
  ↓ WebSocket 메시지: { "type": "robot_command", "command": "move_up", "value": 1 }
[Jetson] WebSocket 메시지 수신
  ↓ 명령 처리
  ↓ RPi로 전송 (내부 유선연결)
[RPi] 모터 제어
  ↓ 명령 실행
  ↓ 완료 신호 전송
[Jetson → 앱] WebSocket 메시지: { "type": "robot_status", "status": "MOVING", "position": { "x": 3, "y": 3, "z": 50 } }
[앱] 상태 업데이트
```

**UX 요구사항:**
- 버튼 클릭 시 즉시 피드백 제공
- 상태 표시 클릭 시 모달로 상세 정보 표시
- 슬라이더 드래그 시 실시간 값 표시

---

### 4.4 데이터 모델

**관련 모델:**
- Session
- UserManualPreset
- UserDeviceConnection

**필드 관계:**
```
User (1) → UserManualPreset (N)
Session (1) → UserManualPreset (N)
```

---

### 4.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| 로봇 상태 업데이트 | PUT | `/api/sessions/{session_id}/robot-status` | 로봇 상태 변경 | 1초 |
| 프리셋 저장 | PUT | `/api/user-manual-presets/{user_id}` | 수동 제어 프리셋 저장 | 2초 |
| 프리셋 조회 | GET | `/api/user-manual-presets/{user_id}/active` | 활성 프리셋 조회 | 2초 |

---

### 4.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| WebSocket 연결 안됨 | 400 | WEBSOCKET_DISCONNECTED | "기기가 연결되지 않았습니다." | 연결 재시도 |
| 기기 응답 시간 초과 | 400 | DEVICE_TIMEOUT | "기기 응답 시간이 초과되었습니다." | 명령 재전송 |
| 기기 사용 중 | 400 | DEVICE_BUSY | "기기가 현재 사용 중입니다." | 대기 후 재시도 |

---

### 4.7 UX 요구사항

| 항목 | 요구사항 |
|------|----------|
| 음성 명령 피드백 | 실시간 인식된 텍스트 표시 (Jetson → 앱 WebSocket)
| 로봇 상태 표시 | 상태별 색상 구분 (회색, 녹색, 파란색, 주황색) |
| 버튼 피드백 | 클릭 시 즉시 시각적 피드백 제공 |
| 명령 완료 메시지 | 완료 후 명확한 메시지 표시 |
| 모달 상세 정보 | 상태 표시 클릭 시 상세 정보 모달 |

---

### 4.8 Timeout 설정 요약

| 항목 | Timeout | 설명 |
|------|---------|------|
| 음성 인식 타임아웃 | 2초 | 음성 명령 대기 시 타임아웃 |
| 기기 응답 시간 | 200ms | 기기 명령 응답 시간 |
| 로봇 상태 업데이트 | 1초 | 로봇 상태 변경 API Timeout |

---

### 4.9 보안 요구사항

| 항목 | 요구사항 |
|------|----------|
| WebSocket 연결 확인 | 세션의 connection_status 확인 |
| 명령 전송 | HTTPS/TLS 암호화 및 WebSocket 보안 |
| 세션 유효성 확인 | JWT 토큰 확인 |

---

## 5. 핸드프리 유튜브 제어

### 5.1 기능 개요

**목적:** 사용자가 음성 명령으로 유튜브와 같은 외부 앱을 제어할 수 있도록 안드로이드 접근성 서비스를 활용

**필수 구성요소:**
- 핸드프리 제어 토글 버튼
- 접근성 권한 확인
- 음성 명령 처리 (유튜브 뒤로/앞으로 감기, 정지/재생, 볼륨 조절)
- Foreground Service (백그라운드 유지)

**선행 조건:**
- 앱 최초 실행 시 접근성 서비스 권한 허용
- 사용자가 로그인에 성공
- WebSocket 연결 되어 있거나 60분 유예 세션 내

**후행 조건:**
- 핸드프리 제어 활성화 시 Foreground Service 시작
- 음성 명령 실행 시 제스처 시뮬레이션
- 세션 만료 시 모든 제어 로직 차단

---

### 5.2 페이지 전환 흐름

```
제어 메인 - 홈 탭
    ↓ (핸드프리 제어 토글 ON)
접근성 권한 확인
    ↓ (권한 허용)
핸드프리 모드 활성화
    ↓ (음성 명령 인식)
유튜브 제어 명령 실행
```

---

### 5.3 상세 흐름 및 데이터 흐름

#### 5.3.1 앱 최초 실행 시 접근성 권한 요청

**권한 요청 타이밍:** 앱 최초 실행 시

**페이지 전환:**
없음, 권한 안내 팝업 표시

**권한 안내 팝업:**
- 메시지: "유튜브 조작을 위해 접근성 권한이 필요합니다."
- 설명: "SARVIS 앱이 유튜브와 같은 다른 앱을 제어하려면 시스템 설정에서 접근성 권한을 허용해야 합니다."
- "설정하러 가기" 버튼 클릭 → 안드로이드 시스템 접근성 설정 화면으로 이동
- "취소" 버튼 클릭 → 팝업 종료

**UX 요구사항:**
- 권한 안내 팝업은 앱 최초 실행 시 1회만 표시

---

#### 5.3.2 핸드프리 제어 활성화

**핸드프리 제어 토글 버튼:** 음성 명령으로 유튜브 제어 활성화/비활성화

**페이지 전환:**
없음, 토글 버튼으로 제어

**활성화 절차:**
1. 사용자가 핸드프리 제어 토글 버튼을 ON으로 설정
2. 앱이 접근성 서비스 권한 상태 확인
3. **권한 허용 상태:**
   - Foreground Service 시작
4. **권한 미승인 상태:**
   - "접근성 권한이 필요합니다." 안내 팝업
   - "설정하러 가기"/취소 버튼 노출
   - 토글 자동 OFF로 변경

---

#### 5.3.3 핸드프리 제어 명령 (음성)

**명령 흐름:**
```
Jetson: 음성 인식 → 명령 파싱 → 앱: WebSocket JSON 전송
앱: JSON 수신 → Android Native: 제스처 시뮬레이션 → 유튜브: 제어 실행
```

**핸드프리 제어 명령 목록:**

1. **"유튜브 뒤로 감기"**
   - Jetson: 음성 "유튜브 뒤로" 인식
   - Jetson → 앱: WebSocket 메시지 `{"cmd": "youtube_control", "action": "rewind", "value": 10}`
   - Android Native: Accessibility Service로 좌측 더블 탭 제스처 시뮬레이션
   - 유튜브: 10초 뒤로 감기

2. **"유튜브 앞으로 감기"**
   - Jetson: 음성 "유튜브 앞으로" 인식
   - Jetson → 앱: WebSocket 메시지 `{"cmd": "youtube_control", "action": "forward", "value": 10}`
   - Android Native: Accessibility Service로 우측 더블 탭 제스처 시뮬레이션
   - 유튜브: 10초 앞으로 감기

3. **"유튜브 정지/재생"**
   - Jetson: 음성 "유튜브 정지" 또는 "유튜브 재생" 인식
   - Jetson → 앱: WebSocket 메시지 `{"cmd": "youtube_control", "action": "toggle_play"}`
   - Android Native: Accessibility Service로 중앙 탭 제스처 시뮬레이션
   - 유튜브: 정지/재생 토글

4. **"유튜브 볼륨 올려"**
   - Jetson: 음성 "유튜브 볼륨 올려" 인식
   - Jetson → 앱: WebSocket 메시지 `{"cmd": "youtube_control", "action": "volume_up"}`
   - Android Native: 볼륨 업 제스처 시뮬레이션
   - 유튜브: 볼륨 +1

5. **"유튜브 볼륨 내려"**
   - Jetson: 음성 "유튜브 볼륨 내려" 인식
   - Jetson → 앱: WebSocket 메시지 `{"cmd": "youtube_control", "action": "volume_down"}`
   - Android Native: 볼륨 다운 제스처 시뮬레이션
   - 유튜브: 볼륨 -1

**Android Native 제스처 매핑:**
| 명령 (action) | 제스처 | 유튜브 동작 |
|--------------|---------|------------|
| rewind | 좌측 더블 탭 | 10초 뒤로 감기 |
| forward | 우측 더블 탭 | 10초 앞으로 감기 |
| toggle_play | 중앙 탭 | 정지/재생 토글 |
| volume_up | 볼륨 업 제스처 | 볼륨 +1 |
| volume_down | 볼륨 다운 제스처 | 볼륨 -1 |

**Timeout 설정:** 100ms
- 제스처 시뮬레이션: 100ms 이내

---

#### 5.3.4 세션 및 보안 제한

**활성 연결 모드** (WebSocket 연결 중):
- 세션의 connection_status가 "CONNECTED"

**60분 유예 세션** (WebSocket 연결 끊김 후 60분 내):
- 세션의 connection_status가 "GRACE_PERIOD"

**세션 만료** (60분 경과 또는 JWT 만료):
- "세션이 만료되었습니다. 다시 로그인해주세요." 안내
- 모든 제어 로직 차단

**데이터 흐름:**
```
[Jetson] 음성 인식
  ↓ 명령 파싱
  ↓ JSON 생성
[Jetson → 앱] WebSocket 메시지: { "type": "youtube_control", "cmd": "youtube_control", "action": "rewind", "value": 10 }
[앱] WebSocket 메시지 수신
  ↓ 세션 유효성 확인
  ↓ 세션 유효 시 제스처 시뮬레이션 실행
  ↓ 세션 만료 시 제어 차단
[Android Native] Accessibility Service로 제스처 시뮬레이션
[유튜브] 제어 실행
```

**UX 요구사항:**
- 세션 만료 시 제어 차단 및 안내 메시지 표시

---

#### 5.3.5 백그라운드 유지

**Android Native Foreground Service 실행:**
- WebSocket 연결 유지
- 음성 명령 대기 상태 유지
- 백그라운드에서도 음성 명령 수신 가능

**데이터 흐름:**
```
[앱] Foreground Service 시작
  ↓ 백그라운드 유지
  ↓ WebSocket 연결 유지
  ↓ 음성 명령 대기
[Jetson] 음성 인식 (백그라운드)
  ↓ 명령 전송 (WebSocket)
[앱] 수신 및 처리
```

---

### 5.4 데이터 모델

**관련 모델:**
- Session

**필드:**
```python
class Session(models.Model):
    robot_status = models.CharField(max_length=25, default='IDLE')
    connection_status = models.CharField(max_length=20, choices=ConnectionStatus.choices, default='CONNECTED')
```

**RobotStatus Enum:**
```python
class RobotStatus(models.TextChoices):
    IDLE = 'IDLE', '로봇 명령 대기'
    TRACKING = 'TRACKING', '사용자 추적'
    MOVING = 'MOVING', '명령에 따른 이동'
    ASIDE = 'ASIDE', '시야 밖으로 이동'
    HANDSFREE_CONTROL = 'HANDSFREE_CONTROL', '핸드프리 유튜브 제어 중'
```

**ConnectionStatus Enum:**
```python
class ConnectionStatus(models.TextChoices):
    CONNECTED = 'CONNECTED', '기기 연결 중'
    GRACE_PERIOD = 'GRACE_PERIOD', '60분 유예 세션'
    EXPIRED = 'EXPIRED', '세션 만료'
```

---

### 5.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| 로봇 상태 업데이트 | PUT | `/api/sessions/{session_id}/robot-status` | 로봇 상태 변경 | 1초 |
| 현재 세션 조회 | GET | `/api/sessions/current` | 현재 세션 확인 | 2초 |
| WebSocket 핸드프리 제어 | WebSocket | `/ws/sessions/{session_id}` | 핸드프리 제어 명령 수신 | 100ms |

---

### 5.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| 세션 만료 | 401 | SESSION_EXPIRED | "세션이 만료되었습니다. 다시 로그인해주세요." | 재로그인 요청 |
| 접근성 권한 없음 | 403 | COMMON_003 | "접근성 권한이 필요합니다." | 권한 설정 유도 |
| WebSocket 연결 안됨 | 400 | WEBSOCKET_DISCONNECTED | "기기가 연결되지 않았습니다." | 연결 재시도 |

---

### 5.7 UX 요구사항

| 항목 | 요구사항 |
|------|----------|
| 권한 안내 | 앱 최초 실행 시 권한 안내 팝업 표시 |
| 세션 만료 안내 | 세션 만료 시 제어 차단 및 안내 메시지 표시 |
| 백그라운드 유지 | Foreground Service로 백그라운드에서도 음성 명령 수신 가능 |

---

### 5.8 Timeout 설정 요약

| 항목 | Timeout | 설명 |
|------|---------|------|
| 제스처 시뮬레이션 | 100ms | 제스처 실행 시간 |
| 로봇 상태 업데이트 | 1초 | 로봇 상태 변경 API Timeout |
| 현재 세션 조회 | 2초 | 현재 세션 확인 API Timeout |

---

### 5.9 보안 요구사항

| 항목 | 요구사항 |
|------|----------|
| 세션 유효성 확인 | JWT 토큰 및 connection_status 확인 |
| 접근성 서비스 권한 | Android Native에서 권한 확인 |
| 제스처 시뮬레이션 | Accessibility Service로만 제어 가능 |
| 세션 만료 시 차단 | 실제 제어 명령 실행 차단 |

---

## 7. 생체 정보 관리

### 7.1 기능 개요

**목적:** 사용자의 얼굴 및 음성 정보를 등록, 재설정, 관리하여 인증 및 제어 기능을 제공

**필수 구성요소:**
- 얼굴 벡터 관리 (등록, 재설정)
- 음성 벡터 관리 (등록, 재설정)
- BiometricLog (변경 이력 기록)

**선행 조건:**
- 얼굴 재설정: 사용자가 메뉴에서 "얼굴 재설정" 선택
- 음성 재설정: 사용자가 메뉴에서 "음성 재설정" 선택

**후행 조건:**
- 재설정 완료 후 기존 벡터 백업
- BiometricLog에 변경 이력 저장

---

### 7.2 페이지 전환 흐름

```
메뉴
    ↓ ("얼굴 재설정" 선택)
얼굴 재설정 화면
    ↓ (재설정 완료)
메인화면 홈탭으로 복귀

메뉴
    ↓ ("음성 재설정" 선택)
음성 재설정 화면
    ↓ (재설정 완료)
메인화면 홈탭으로 복귀
```

---

### 7.3 상세 흐름 및 데이터 흐름

#### 7.3.1 얼굴 재설정

**화면:** 얼굴 재설정 화면

**페이지 전환:**
메뉴 → 얼굴 재설정 화면 → 홈 화면

**실행 흐름:**
1. 메뉴에서 "얼굴 정보 재설정" 선택
2. 얼굴 재설정 화면으로 이동
3. Jetson에서 얼굴 스캔 시작 요청
4. Jetson 카메라 활성화 및 얼굴 스캔 시작
5. 얼굴 원본 이미지 캡처
6. 앱에서 얼굴 원본 이미지를 Jetson의 HTTP 엔드포인트로 전송 (http://192.168.x.x:8000/biometric/face-update)
7. Jetson에서 로컬 임베딩 연산 수행 (얼굴 벡터 추출, 512-dim)
8. Jetson에서 추출된 벡터 데이터를 EC2 서버로 전송
9. "사용자 얼굴 정보를 덮어씌우겠습니까?" 등록 / 취소 선택
10. 등록 시 "사용자 얼굴 정보 재설정 완료!" 메시지
11. 홈 화면으로 복귀

**Timeout 설정:** 10초
- 얼굴 스캔 10초 Timeout

**취소:**
- "취소" 버튼 클릭
- "얼굴 재설정을 취소하시겠습니까?" 확인 팝업
- 확인 시 홈 화면으로 복귀 (재설정 전 기존 정보 유지)

**데이터 흐름:**
```
[앱] 메뉴에서 얼굴 재설정 선택
  ↓ 얼굴 재설정 화면으로 이동
  ↓ Jetson에서 얼굴 스캔 시작 요청 (WebSocket)
[Jetson] WebSocket 메시지 수신
  ↓ 카메라 활성화
  ↓ 얼굴 스캔 (10초)
  ↓ 얼굴 이미지 캡처 (JPEG/PNG, 최대 5MB)
  ↓ POST http://192.168.x.x:8000/biometric/face-update (FormData multipart/form-data: face_image)
[Jetson] 
  ↓ 얼굴 이미지 수신
  ↓ 로컬 임베딩 연산 수행 (얼굴 벡터 추출, 512-dim)
  ↓ 벡터화 완료
  ↓ POST /api/users/{user_id}/face (face_vector: JSON array)
[서버] 
  ↓ 벡터 데이터 수신
  ↓ 기존 face_vector 백업
  ↓ 새 face_vector 저장
  ↓ BiometricLog에 변경 이력 저장
  ↓ 응답: { "success": true, "message": "얼굴 재설정 완료" }
[Jetson → 앱] WebSocket 메시지: { "type": "face_update", "status": "SUCCESS" }
[앱] 신호 수신 후 "사용자 얼굴 정보 재설정 완료!" 메시지 표시
  ↓ 1초 후 홈 화면으로 복귀
```

**참고:**
- **앱:** 얼굴 원본 이미지를 수집하여 Jetson HTTP 엔드포인트로 전송
- **Jetson:** 얼굴 이미지 벡터화 담당 (로컬 임베딩 연산)
- **서버:** 벡터 저장 및 이력 기록 담당
- **S3:** 원본 이미지 저장 금지 (Jetson에서 처리)

**Jetson HTTP 엔드포인트:**
- **URL:** `http://192.168.x.x:8000/biometric/face-update`
- **Method:** POST
- **Request:** FormData `{ face_image: File }`
- **Response (성공):**
```json
{
  "success": true,
  "message": "얼굴 재설정 완료"
}
```
- **Timeout:** 3초

---

#### 7.3.2 음성 재설정

**화면:** 음성 재설정 화면

**페이지 전환:**
메뉴 → 음성 재설정 화면 → 홈 화면

**실행 흐름:**
1. 메뉴에서 "음성 재설정" 선택
2. 음성 재설정 화면으로 이동
3. Jetson에서 음성 재등록 시작 요청
4. "음성 재등록 시작" 버튼 클릭
5. 음성 등록 문장 예시 표시: "SARVIS를 불러보세요"
6. "녹음 중..." 메시지 + 실시간 파형 애니메이션
7. 인식 완료 시 "인식 성공!" 후 필요할 때까지 반복
8. 음성 벡터 수집 진행률 표시 (예: 33% → 66% → 100%)
9. 충분한 음성 원본 오디오 수집 완료
10. 음성 원본 오디오를 Jetson의 HTTP 엔드포인트로 전송 (http://192.168.x.x:8000/biometric/voice-update)
11. EC2에서 음성 오디오 벡터화 (256-dim)
12. "음성 정보 인식 완료!" 메시지
13. "음성 정보를 덮어씌우겠습니까?" 등록 / 취소 선택
14. 등록 시 "음성 재설정 완료!" 메시지
15. 홈 화면으로 복귀

**Timeout 설정:** 3초
- 음성 인식 3초 Timeout

**음성 인식 실패:**
- 3초 안에 "SARVIS"를 인식하지 못했을 시 인식 실패
- "인식 실패!" 후 필요할 때까지 "녹음 중..." 반복

**취소:**
- "취소" 버튼 클릭
- "음성 재설정을 취소하시겠습니까?" 확인 팝업
- 확인 시 홈 화면으로 복귀 (재설정 전 기존 정보 유지)

**음성 등록 건너뛰기:**
- "건너뛰기" 버튼 클릭
- "음성 명령 기능을 사용할 수 없습니다. 나중에 설정에서 등록할 수 있습니다." 안내
- 확인 시 바로 제어 메인 화면으로 이동
- 음성 벡터는 null로 서버에 저장

**데이터 흐름:**
```
[앱] 메뉴에서 음성 재설정 선택
  ↓ 음성 재설정 화면으로 이동
  ↓ Jetson에서 음성 재등록 시작 요청 (WebSocket)
[Jetson] WebSocket 메시지 수신
  ↓ 마이크 활성화 (2개)
  ↓ 음성 수집 시작
  ↓ "SARVIS" 인식 (3초 Timeout)
  ↓ 인식 성공 시 음성 오디오 캡처 (WAV/MP3, 최대 10MB)
  ↓ 진행률 33% → 66% → 100%
  ↓ 충분한 음성 원본 오디오 수집 완료
  ↓ POST http://192.168.x.x:8000/biometric/voice-update (FormData multipart/form-data: voice_audio)
[Jetson] 
  ↓ 음성 오디오 수신
  ↓ 로컬 임베딩 연산 수행 (음성 벡터 추출, 256-dim)
  ↓ 벡터화 완료
  ↓ POST /api/users/{user_id}/voice (voice_vector: JSON array)
[서버] 
  ↓ 벡터 데이터 수신
  ↓ 기존 voice_vector 백업
  ↓ 새 voice_vector 저장
  ↓ BiometricLog에 변경 이력 저장
  ↓ 응답: { "success": true, "message": "음성 재설정 완료" }
[Jetson → 앱] WebSocket 메시지: { "type": "voice_update", "status": "SUCCESS" }
[앱] 신호 수신 후 "음성 재설정 완료!" 메시지 표시
  ↓ 1초 후 홈 화면으로 복귀
```

**참고:**
- **앱:** 음성 원본 오디오를 수집하여 Jetson HTTP 엔드포인트로 전송
- **Jetson:** 음성 오디오 벡터화 담당 (로컬 임베딩 연산)
- **서버:** 벡터 저장 및 이력 기록 담당

**Jetson HTTP 엔드포인트:**
- **URL:** `http://192.168.x.x:8000/biometric/voice-update`
- **Method:** POST
- **Request:** FormData `{ voice_audio: File }`
- **Response (성공):**
```json
{
  "success": true,
  "message": "음성 재설정 완료"
}
```
- **Timeout:** 3초

---

### 7.4 데이터 모델

**관련 모델:**
- User
- BiometricLog

**필드 관계:**
```
User (1) → BiometricLog (N)
```

**BiometricLog 모델 필드:**
```python
class BiometricLog(models.Model):
    biometric_history_id = models.AutoField(primary_key=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    change_type = models.CharField(max_length=20)
    previous_vector = models.JSONField(null=True, blank=True)
    new_vector = models.JSONField(null=True, blank=True)
    changed_at = models.DateTimeField(auto_now_add=True)
    change_reason = models.TextField(null=True, blank=True)
```

**ChangeType Enum:**
```python
class BiometricLog(models.Model):
    class ChangeType(models.TextChoices):
        FACE_INITIAL = 'FACE_INITIAL', '얼굴 초기 등록'
        VOICE_INITIAL = 'VOICE_INITIAL', '음성 초기 등록'
        FACE_UPDATE = 'FACE_UPDATE', '얼굴 재설정'
        VOICE_UPDATE = 'VOICE_UPDATE', '음성 재설정'
```

---

### 7.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| 얼굴 재설정 | PUT | `/api/users/{user_id}/face` | 얼굴 원본 이미지 Jetson 전송 및 벡터화 | 3초 |
| 음성 재설정 | PUT | `/api/users/{user_id}/voice` | 음성 원본 오디오 Jetson 전송 및 벡터화 | 3초 |

---

### 7.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| 권한 없음 | 403 | COMMON_003 | "권한이 없습니다." | 재로그인 요청 |
| 벡터 형식 오류 | 400 | INVALID_FACE_VECTOR / INVALID_VOICE_VECTOR | "유효하지 않은 벡터입니다." | 재등록 요청 |
| S3 업로드 실패 | 500 | S3_UPLOAD_FAILED | "파일 업로드에 실패했습니다." | 재시도 요청 |
| EC2 벡터화 실패 | 500 | VECTORIZATION_FAILED | "벡터화에 실패했습니다." | 재시도 요청 |

---

### 7.7 UX 요구사항

| 항목 | 요구사항 |
|------|----------|
| 재설정 확인 | 덮어씌우기 전 확인 팝업 표시 |
| 취소 확인 | 취소 시 확인 팝업 표시 |
| 진행률 표시 | 음성 재설정 진행률 표시 (33% → 66% → 100%) |
| 완료 메시지 | 재설정 완료 후 명확한 메시지 표시 |

---

### 7.8 Timeout 설정 요약

| 항목 | Timeout | 설명 |
|------|---------|------|
| 얼굴 스캔 Timeout | 10초 | 얼굴 이미지 캡처 시간 |
| 음성 인식 Timeout | 3초 | "SARVIS" 인식 Timeout |
| API 요청 Timeout | 3초 | 얼굴/음성 재설정 API Timeout |

---

### 7.9 보안 요구사항

| 항목 | 요구사항 |
|------|----------|
| 벡터 백업 | BiometricLog에 previous_vector 저장 |
| 권한 확인 | 자신의 벡터만 재설정 가능 |
| 변경 이력 기록 | BiometricLog에 모든 변경 기록 |
| 원본 파일 처리 | 벡터화 완료 후 즉시 삭제 |
| Jetson HTTP 엔드포인트 보안 | 로컬 네트워크 내 Jetson → 앱 직접 통신 (192.168.x.x)

---

## 8. 기기 관리

### 8.1 기능 개요

**목적:** 사용자가 SARVIS 기기의 정보를 조회하고 펌웨어 업데이트를 확인

**필수 구성요소:**
- 기기 정보 조회

**선행 조건:**
- 사용자가 로그인에 성공

**후행 조건:**
- 기기 정보 표시

---

### 8.2 페이지 전환 흐름

```
메뉴
    ↓ ("기기 정보" 선택)
기기 정보 화면
    ↓ ("뒤로" 버튼 클릭)
홈 화면으로 복귀
```

---

### 8.3 상세 흐름 및 데이터 흐름

#### 8.3.1 기기 정보 조회

**화면:** 기기 정보 화면

**페이지 전환:**
메뉴 → 기기 정보 화면 → 홈 화면

**실행 흐름:**
1. 메뉴에서 "기기 정보" 선택
2. 기기 정보 화면으로 이동
3. 기기 정보 표시:
   - 기기 타입 (SARVIS-Pro)
   - Serial Number (SN-00123456789)
   - 펌웨어 버전 (1.0.0)
   - 앱 버전 (1.0.0)
   - 최신 앱 버전 확인

**데이터 흐름:**
```
[앱] 메뉴에서 기기 정보 선택
  ↓ 기기 정보 화면으로 이동
  ↓ 앱 버전 확인
  ↓ GET /api/devices/current
[서버] 
  ↓ 기기 정보 조회
  ↓ 펌웨어 버전 확인
  ↓ 최신 앱 버전 확인
[앱] 기기 정보 표시
```

**API:**
- **Method:** `GET`
- **URL:** `/api/devices/current`
- **Response (성공):**
```json
{
  "success": true,
  "data": {
    "device_type": "SARVIS-Pro",
    "serial_number": "SN-00123456789",
    "firmware_version": "1.0.0",
    "app_version": "1.0.0",
    "latest_firmware_version": "1.0.0"
  }
```
- **Timeout:** 2초

---

### 8.4 데이터 모델

**관련 모델:**
- Device
- UserDeviceConnection

**필드 관계:**
```
Device (1) → UserDeviceConnection (N)
User (1) → UserDeviceConnection (N)
```

**Device 모델 필드:**
```python
class Device(models.Model):
    device_id = models.AutoField(primary_key=True)
    device_type = models.CharField(max_length=50)
    serial_number = models.CharField(max_length=50, unique=True)
    firmware_version = models.CharField(max_length=20)
    latest_firmware_version = models.CharField(max_length=20, null=True)
```

---

### 8.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| 기기 정보 조회 | GET | `/api/devices/current` | 현재 연결된 기기 정보 조회 | 2초 |

---

### 8.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| WebSocket 연결 안됨 | 400 | WEBSOCKET_DISCONNECTED | "기기가 연결되지 않았습니다." | 연결 재시도 |

---

### 8.7 UX 요구사항

| 항목 | 요구사항 |
|------|----------|
| 기기 정보 표시 | 기기 타입, Serial Number, 버전 명확히 표시 |
| 업데이트 알림 | 새 펌웨어 버전 있을 때 알림 표시 |
| "뒤로" 버튼 | 홈 화면으로 복귀 |

---

### 8.8 Timeout 설정 요약

| 항목 | Timeout | 설명 |
|------|---------|------|
| 기기 정보 조회 | 2초 | 기기 정보 API Timeout |

---

### 8.9 보안 요구사항

| 항목 | 요구사항 |
|------|----------|
| 세션 유효성 확인 | JWT 토큰 확인 |
| 기기 소유권 확인 | 사용자가 연결된 기기의 소유자인지 확인 |

---

## 9. 프리셋 관리

### 9.1 기능 개요

**목적:** 사용자가 로봇 제어 위치를 프리셋으로 저장하고 불러오기

**필수 구성요소:**
- 프리셋 저장
- 프리셋 조회
- 프리셋 복구

**선행 조건:**
- 사용자가 로그인에 성공
- WebSocket 연결 되어 있어야 함

**후행 조건:**
- 프리셋 저장/복구 완료

---

### 9.2 페이지 전환 흐름

```
제어 탭
    ↓ (수동 제어 완료)
"프리셋 저장" 버튼 클릭
    ↓ 프리셋 이름 설정
프리셋 저장 완료

제어 탭
    ↓ 수동 제어
"프리셋 불러오기" 버튼 클릭
    ↓ 프리셋 목록 모달
프리셋 선택
    ↓ 프리셋 복구
프리셋 복구 완료
```

---

### 9.3 상세 흐름 및 데이터 흐름

#### 9.3.1 프리셋 저장

**화면:** 제어 탭

**페이지 전환:**
페이지 전환 없음, 제어 탭 내 저장

**실행 흐름:**
1. 원하는 위치로 수동 제어
2. "프리셋 저장" 버튼 클릭
3. 프리셋 이름 설정 필드 팝업(기본값: "프리셋 {가장 작은 사용하지 않는 번호}")
4. 이름 설정 후 프리셋 저장 활성화
5. "현재 설정이 저장되었습니다.\n좌(우) 3, 위(아래) 3, 왼쪽(오른쪽) 각도 0°, 위쪽 각도(아래쪽) 0°, 거리: 3단계" 알림

**데이터 흐름:**
```
[앱] 프리셋 저장 버튼 클릭
  ↓ 프리셋 이름 설정
  ↓ PUT /api/user-manual-presets/{user_id}
[서버] 
  ↓ UserManualPreset 생성
  ↓ 응답: { "success": true, "message": "프리셋 저장 완료" }
[앱] "현재 설정이 저장되었습니다." 메시지 표시
```

**API:**
- **Method:** `PUT`
- **URL:** `/api/user-manual-presets/{user_id}`
- **Request Body:**
```json
{
  "preset_name": "내 프리셋 1",
  "x": 3,
  "y": 3,
  "z": 50,
  "tilt": 0,
  "has": 0
}
```
- **Response (성공):**
```json
{
  "success": true,
  "message": "프리셋 저장 완료"
}
```
- **Timeout:** 2초

---

#### 9.3.2 프리셋 불러오기

**화면:** 제어 탭

**페이지 전환:**
페이지 전환 없음, 프리셋 목록 모달

**실행 흐름:**
1. "프리셋 불러오기" 버튼 클릭
2. 프리셋 목록 모달 표시
3. 저장된 모든 프리셋 목록 표시
4. 프리셋 선택

**데이터 흐름:**
```
[앱] "프리셋 불러오기" 버튼 클릭
  ↓ 프리셋 목록 모달 표시
  ↓ GET /api/user-manual-presets/{user_id}
[서버] 
  ↓ 사용자 프리셋 목록 조회
[앱] 프리셋 목록 표시
  ↓ 사용자 프리셋 선택
  ↓ 프리셋 복구 (제어 값 적용)
```

**API:**
- **Method:** `GET`
- **URL:** `/api/user-manual-presets/{user_id}`
- **Response (성공):**
```json
{
  "success": true,
  "data": [
    {
      "preset_id": 1,
      "preset_name": "내 프리셋 1",
      "x": 3,
      "y": 3,
      "z": 50,
      "tilt": 0,
      "has": 0
    }
  ]
}
```
- **Timeout:** 2초

---

#### 9.3.3 프리셋 복구

**화면:** 제어 탭

**페이지 전환:**
페이지 전환 없음, 제어 탭 내 복구

**실행 흐름:**
1. 프리셋 목록에서 프리셋 선택
2. "기존 프리셋으로 복구하시겠습니까?" 확인 팝업
3. 확인 시 모든 값이 프리셋 값으로 변경 및 로봇 위치 이동 명령 전송
4. "프리셋으로 복구되었습니다.\n좌(우) 3, 위(아래) 3, 왼쪽(오른쪽) 각도 0°, 위쪽 각도(아래쪽) 0°, 거리: 3단계" 알림

**데이터 흐름:**
```
[앱] 프리셋 선택
  ↓ 확인 팝업
  ↓ 프리셋 복구 (제어 값 적용)
  ↓ WebSocket 메시지: { "type": "robot_command", "command": "restore_preset", "preset_id": 1 }
[Jetson] WebSocket 메시지 수신
  ↓ 명령 처리
  ↓ RPi로 전송 (내부 유선연결)
[RPi/Jetson] 명령 수신 및 실행
  ↓ 완료 신호 전송
[앱] "프리셋으로 복구되었습니다." 메시지
```

**UX 요구사항:**
- 프리셋 복구 시 확인 팝업 표시
- 취소 시 팝업만 종료
- 복구 완료 후 명확한 메시지 표시

---

### 9.4 데이터 모델

**관련 모델:**
- UserManualPreset
- Session

**필드 관계:**
```
User (1) → UserManualPreset (N)
Session (1) → UserManualPreset (N)
```

**UserManualPreset 모델 필드:**
```python
class UserManualPreset(models.Model):
    preset_id = models.AutoField(primary_key=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    session = models.ForeignKey(Session, on_delete=models.CASCADE)
    preset_name = models.CharField(max_length=50)
    x = models.IntegerField()
    y = models.IntegerField()
    z = models.IntegerField()
    tilt = models.IntegerField()
    has = models.IntegerField()
    created_at = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=False)
```

---

### 9.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| 프리셋 저장 | PUT | `/api/user-manual-presets/{user_id}` | 수동 제어 프리셋 저장 | 2초 |
| 프리셋 조회 | GET | `/api/user-manual-presets/{user_id}` | 사용자 프리셋 목록 조회 | 2초 |

---

### 9.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| WebSocket 연결 안됨 | 400 | WEBSOCKET_DISCONNECTED | "기기가 연결되지 않았습니다." | 연결 재시도 |
| 프리셋 미존재 | 404 | PRESET_NOT_FOUND | "프리셋을 찾을 수 없습니다." | 다시 조회 요청 |

---

### 9.7 UX 요구사항

| 항목 | 요구사항 |
|------|----------|
| 프리셋 이름 설정 | 기본값: "프리셋 {가장 작은 사용하지 않는 번호}" |
| 프리셋 복구 확인 | 복구 전 확인 팝업 표시 |
| 완료 메시지 | 복구 완료 후 명확한 메시지 표시 |
| 모달 목록 | 프리셋 목록 모달로 표시 |

---

### 9.8 Timeout 설정 요약

| 항목 | Timeout | 설명 |
|------|----------|------| 프리셋 저장 | 2초 | 프리셋 저장 API Timeout |
| 프리셋 조회 | 2초 | 프리셋 조회 API Timeout |

### 9.9 보안 요구사항| 항목 | 요구사항 |
|------|----------|
| 사용자 권한 확인 | 자신의 프리셋만 저장/복구 가능|
| 세션 유효성 확인 | JWT 토큰 확인|

---

## 10. 회원 관리

### 10.1 기능 개요

**목적:** 사용자가 로그아웃 및 회원 탈퇴를 수행

**필수 구성요소:**
- 로그아웃
- 회원 탈퇴

**선행 조건:**
- 사용자가 로그인에 성공

**후행 조건:**
- 로그아웃: 로그인 초기 화면으로 이동
- 회원 탈퇴: 로그인 초기 화면으로 이동

---

### 10.2 페이지 전환 흐름

```
메뉴
    ↓ ("로그아웃" 선택)
로그아웃 확인 팝업
    ↓ (확인)
로그아웃 완료
    ↓
로그인 초기 화면으로 이동

메뉴
    ↓ ("회원 탈퇴" 선택)
회원 탈퇴 화면
    ↓ (탈퇴 사유 입력)
탈퇴 확인 팝업
    ↓ (확인)
회원 탈퇴 완료
    ↓
로그인 초기 화면으로 이동
```

---

### 10.3 상세 흐름 및 데이터 흐름

#### 10.3.1 로그아웃

**화면:** 메뉴

**페이지 전환:**
메뉴 → 로그아웃 확인 팝업 → 로그인 초기 화면

**실행 흐름:**
1. 사용자가 메뉴에서 "로그아웃" 선택
2. "로그아웃하시겠습니까?" 확인 팝업
3. 확인 시 로그아웃 진행
4. 세션 종료, JWT 토큰 삭제
5. WebSocket 연결 종료
6. 로그인 초기 화면으로 이동

**데이터 흐름:**
```
[앱] 메뉴에서 로그아웃 선택
  ↓ 확인 팝업
  ↓ POST /api/auth/logout
[서버] 
  ↓ 세션 종료
  ↓ JWT 토큰 무효화
  ↓ WebSocket 연결 종료
[앱] 로그인 초기 화면으로 이동
  ↓ 로컬 토큰 삭제
  ↓ WebSocket 연결 종료
```

**API:**
- **Method:** `POST`
- **URL:** `/api/auth/logout`
- **Request Body:** 없음
- **Response (성공):**
```json
{
  "success": true,
  "message": "로그아웃 완료"
}
```
- **Timeout:** 2초

---

#### 10.3.2 회원 탈퇴

**화면:** 메뉴 → 회원 탈퇴 화면

**페이지 전환:**
메뉴 → 회원 탈퇴 화면 → 로그인 초기 화면

**실행 흐름:**
1. 메뉴에서 "회원 탈퇴" 선택
2. 회원 탈퇴 화면으로 이동
3. "회원 탈퇴 사유를 입력해주세요." 프롬프롬프롬프트
4. 사용자가 탈퇴 사유 드롭다운 또는 직접 입력
5. 취소 버튼 클릭 시 홈 화면으로 복귀
6. 확인 시 회원 탈퇴 진행
8. "회원 탈퇴가 완료되었습니다.\n그동안 이용해 주셔서 감사합니다." 알림
9. 로그아웃 후 로그인 초기 화면으로 이동

**탈퇴 사유 옵션:**
- "서비스 불만족"
- "이용 빈도"
- "개인정보 우려"
- "기타" (직접 입력)

**데이터 흐름:**
```
[앱] 메뉴에서 회원 탈퇴 선택
  ↓ 회원 탈퇴 화면으로 이동
  ↓ 탈퇴 사유 입력
  ↓ DELETE /api/users/{user_id}
[서버] 
  ↓ User 삭제
  ↓ BiometricLog 보존
  ↓ UserDeviceConnection 삭제
  ↓ Session 삭제
[앱] "회원 탈퇴가 완료되었습니다." 메시지
  ↓ 로그아웃
  ↓ 로그인 초기 화면으로 이동
  ↓ 로컬 토큰 삭제
  ↓ WebSocket 연결 종료
```

**API:**
- **Method:** `DELETE`
- **URL:** `/api/users/{user_id}`
- **Request Body:**
```json
{
  "withdrawal_reason": "서비스 불만족"
}
```
- **Response (성공):**
```json
{
  "success": true,
  "message": "회원 탈퇴 완료"
}
```
- **Timeout:** 3초

---

### 10.4 데이터 모델

**관련 모델:**
- User
- Session
- UserDeviceConnection
- BiometricLog

**필드 관계:**
```
User (1) → Session (N)
User (1) → UserDeviceConnection (N)
User (1) → BiometricLog (N)
```

---

### 10.5 API 엔드포인트

| API | Method | URL | 설명 | Timeout |
|-----|---------|------|------|----------|
| 로그아웃 | POST | `/api/auth/logout` | 로그아웃 | 2초 |
| 회원 탈퇴 | DELETE | `/api/users/{user_id}` | 회원 탈퇴 | 3초 |

---

### 10.6 에러 처리

| 에러 상황 | HTTP 상태 | 에러 코드 | 메시지 | 처리 방법 |
|-----------|-----------|----------|--------|----------|
| 권한 없음 | 403 | COMMON_003 | "권한이 없습니다." | 재로그인 요청 |
| 탈퇴 사유 미입력 | 400 | WITHDRAWAL_REASON_REQUIRED | "탈퇴 사유를 입력해주세요." | 사유 입력 요청 |

---

### 10.7 UX 요구사항| 항목 | 요구사항 |
|------|----------|
| 로그아웃 확인 | 로그아웃 전 확인 팝업 표시|
| 회원 탈퇴 확인 | 탈퇴 전 이중 확인 팝업 표시|
| 탈퇴 사유 선택 | 드롭다운 또는 직접 입력|
| 되돌릴 수 없음 안내 | "이 작업은 되돌릴 수 없습니다." 안내|

### 10.8 Timeout 설정 요약| 항목 | Timeout | 설명 |
|------|----------|
| 로그아웃 | 2초 | 로그아웃 API Timeout|
| 회원 탈퇴 | 3초 | 회원 탈퇴 API Timeout|

### 10.9 보안 요구사항| 항목 | 요구사항 |
|------|----------|
| 권한 확인 | 자신의 계정만 탈퇴 가능|
| 세션 종료 | 로그아웃 시 세션 즉시 종료|
| 토큰 삭제 | 로그아웃/탈퇴 시 로컬 토큰 삭제|
| WebSocket 연결 종료 | 로그아웃/탈퇴 시 WebSocket 연결 종료|
| BiometricLog 보존 | 법적적 요구사항에 따라 보존|

---

**문서 버전:** 4.0  
**작성일:** 2026-01-29  
**최종 수정일:** 2026-01-29